{
  "santabaRelease": 229,
  "defaultDashboardFilters": {
    "defaultDashboardFilterDetails": []
  },
  "widgetTokens": [
    {
      "name": "defaultDashboardGroup",
      "value": "LogicMonitor Dashboards/*"
    },
    {
      "name": "DashboardsToExclude",
      "value": ".*[Tt]+emplate.*"
    },
    {
      "name": "ShowFullDashboardPath",
      "value": "false"
    }
  ],
  "name": "Dynamic Dashboard List",
  "description": "",
  "overwriteGroupFields": false,
  "widgetsConfigVersion": 2,
  "type": "dashboard",
  "widgets": [
    {
      "position": {
        "col": 1,
        "sizex": 3,
        "row": 1,
        "sizey": 7
      },
      "config": {
        "displaySettings": {},
        "isSupportCustomProperty": false,
        "supportCustomProperty": false,
        "name": "Dashboard List",
        "description": "",
        "theme": "newBorderGray",
        "interval": 1,
        "type": "text",
        "timescale": "day",
        "version": 2,
        "content": "<!-- \n\tDYNAMIC DASHBOARD LIST v2.0\n\n\tThis script was created in response to a customer needing a quick way to drill-down from an overview dashboard to various specific dashboards. While straightforward to manually make a list in a text widget, we wanted a way to dynamically list dashboards as they were added or changed. To further enhance the functionality, if a 'defaultResourceGroup' token is set on a dashboard group then the script will fetch current alert status for that group (can be disabled via the 'fetchGroupAlertStatus' variable in the script if API limits are an issue).\n\tNOTE: while this script leverages standard LogicMonitor APIs and features, this script itself is not officially supported by LogicMonitor.\n\n\tTo use this, just add a Text widget to your dashboard and in the widget's configuration screen click the \"source\" view then paste in this code. You can also just clone this widget to another dashboard on the same portal.\n\n\t---\n\n\tDASHBOARD TOKENS:\n\t'ShowFullDashboardPath': Show the dashboard group's full path vs it's short name. Default: true.\n\t'defaultDashboardGroup': (optional) The \"parent\" dashboard group you want to list dashboards under. If not set then the script will default to showing all dashboard groups.\n\t'DashboardsToExclude': (optional) A regular expression to filter any dashboards you DON'T want listed. Example: .*[Tt]+emplate.*\n\n--><script>\n\t// Set the following to false if you don't want to fetch group alert status...\n\tconst fetchGroupAlertStatus = true;\n\t\n\t// Maximum number of dashboards to retrieve...\n\tconst maxGroups = 500;\n\t\n\t// How often to automatically refresh the list...\n\tconst statusUpdateIntervalMinutes = 2;\n\t\n\t// Whether to show the group's short name or full path (can alternatively be set via a 'ShowFullDashboardPath' dashboard token)...\n\tlet showFullPath = true;\n\t\n\t// An optional regular expression with any dashboards we don't want listed (can alternative be set via a 'DashboardsToExclude' dashboard token)...\n\tlet exclusionRE = \"\";\n</script><p><link href=\"https://static-prod.logicmonitor.com/sbui133-1/commons/stylesheets2/startup.css?v=220429\" rel=\"stylesheet\"><link href=\"ace/css/ace-chrome\" rel=\"stylesheet\"></p><style type=\"text/css\">\n\t#dashboardListContainer {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tflex-wrap: nowrap;\n\t\talign-items: stretch;\n\t\theight: 100%;\n\t}\n\t.dashboardItem {\n\t\tdisplay: flex;\n\t\tborder: 1px solid #ccc;\n\t\tpadding: 3px;\n\t\tmargin: 5px;\n\t\tborder-radius: 5px;\n\t\tflex-wrap: nowrap;\n\t\tbackground-color: #fafafa;\n\t\theight: 100%;\n\t\tbox-shadow: 0px 1px 4px rgba(0, 0, 0, 0.2);\n\t}\n\t.dashboardItem > div {\n\t\tpadding: 5px 3px;\n\t}\n\t.dashboardItem > div:nth-child(1) {\n\t\tdisplay: flex;\n\t\talign-self: stretch;\n\t\twidth: 100%;\n\t\tflex-direction: column;\n\t\tjustify-content: center;\n\t}\n\t.dashboardItem > div:nth-child(2) {\n\t\tdisplay: flex;\n\t\talign-self: stretch;\n\t\twidth: 50px;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t}\n\t.groupName {\n\t\tfont-weight: 700;\n\t\tfont-size: medium;\n\t\tpadding-bottom: 5px;\n\t}\n\t.dashboardItem.clear {\n\t\tbackground-color: #eaffea;\n\t}\n\t.dashboardItem.warn {\n\t\tbackground-color: lightyellow;\n\t\tcolor: inherit;\n\t}\n\t.dashboardItem.error {\n\t\tbackground-color: #ffe9dc;\n\t\tcolor: inherit;\n\t}\n\t.dashboardItem.critical {\n\t\tbackground-color: #ffe9e6;\n\t\tcolor: inherit;\n\t}\n\t.dashboardListGroupStatus {\n\t\tfont-weight: bold;\n\t}\n\t.dashboardListItem {\n\t\tpadding-left: 15px;\n\t}\n\t.dashboardListItem:hover {\n\t\tbackground-color: white;\n\t}\n\t.warning {\n\t\tbackground-color: rgb(245, 202, 29);\n\t\tpadding: 3px;\n\t\tborder-radius: 3px;\n\t}\n\t.error {\n\t\tbackground-color: rgb(245, 114, 0);\n\t\tcolor: white;\n\t\tpadding: 3px;\n\t\tborder-radius: 3px;\n\t}\n\t.critical {\n\t\tbackground-color: rgb(224, 53, 27);\n\t\tcolor: white;\n\t\tpadding: 3px;\n\t\tborder-radius: 3px;\n\t}\n\t.cleared {\n\t\tbackground-color: #81ae49;\n\t\tcolor: white;\n\t\tpadding: 3px;\n\t\tborder-radius: 3px;\n\t}\n\t.hidden {\n\t\tdisplay: none;\n\t}\n</style><div id=\"dashboardListContainer\">&nbsp;</div><script>\n\t// Capture from token whether to hide the map options...\n\tlet showFullPathToken = \"##ShowFullDashboardPath##\";\n\t// If the token value was't set then use the value hard-coded above at the beginning of this script...\n\tif (showFullPathToken.toLowerCase() == \"false\" || showFullPathToken.toLowerCase() == \"no\"|| showFullPathToken.toLowerCase() == \"0\") {\n\t\tshowFullPath = false;\n\t};\n\n\t// Capture information from specific dashboard tokens we'll be using...\n\n\t// Capture if an exclusion pattern is defined...\n\tlet exclusionREToken = \"##DashboardsToExclude##\";\n\tif (exclusionREToken != \"\\#\\#DashboardsToExclude\\#\\#\") {\n\t\texclusionRE = new RegExp(exclusionREToken);\n\t};\n\n\t// Capture the current values of the tokens...\n\t// (Like any token inserted into the Text widget, LogicMonitor automatically inserts these token values as the page is being rendered so Javascript is able to pick them as if the values were there originally. If a token isn't set then the variable's value will be literally what's shown below, including the double-hashtags.)\n\tlet defaultDashboardGroupValue = \"##defaultDashboardGroup##\";\n\n\t// ---\n\n\t// Capture information about the current dashboard for use in subsequent REST calls...\n\tconst locationHash = parent.window.location.hash; // example result: \"#dashboard=21\"\n\tconst dashboardID = locationHash.replace(\"#dashboard=\", \"\");\n\tconst pathName = parent.window.location.pathname;\n\t\n\t// Variable for referencing our HTML element...\n\tconst dynamicTable = document.getElementById(\"dashboardListContainer\");\n\tlet resourceGroups = [];\n\n\t// Icon definitions for our different alert severities...\n\tconst warningIcon = '<svg id=\"icon-alertsWarning-26\" viewBox=\"0 0 1024 1024\"> <title>Warning</title> <path fill=\"#ffcc00\" d=\"M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z\"></path> <path fill=\"white\" d=\"M866.462 669.538l-275.692-433.231c-43.323-70.892-114.215-70.892-157.538 0l-275.692 433.231c-43.323 70.892-3.938 157.538 78.769 157.538h551.385c82.708 0 122.092-86.646 78.769-157.538v0 0z\"></path> <path fill=\"#ffcc00\" d=\"M551.385 748.308h-78.769v-78.769h78.769v78.769zM551.385 630.154h-78.769v-275.692h78.769v275.692z\"></path> </svg>';\n\tconst errorIcon = '<svg id=\"icon-alertsError-26\" viewBox=\"0 0 1024 1024\"> <title>Error</title> <path fill=\"#f26522\" d=\"M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z\"></path> <path fill=\"white\" d=\"M866.462 669.538l-275.692-433.231c-43.323-70.892-114.215-70.892-157.538 0l-275.692 433.231c-43.323 70.892-3.938 157.538 78.769 157.538h551.385c82.708 0 122.092-86.646 78.769-157.538v0 0z\"></path> <path fill=\"#f26522\" d=\"M551.385 748.308h-78.769v-78.769h78.769v78.769zM551.385 630.154h-78.769v-275.692h78.769v275.692z\"></path> </svg>';\n\tconst criticalIcon = '<svg id=\"icon-alertsCritical-26\" viewBox=\"0 0 1024 1024\"> <title>Critical</title> <path fill=\"#ed1e24\" d=\"M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z\"></path> <path fill=\"white\" d=\"M827.077 590.769c-133.908-232.369-39.385-354.462-39.385-354.462s-173.292 43.323-157.538 157.538c-35.446-31.508-216.615-86.646-114.215-271.754v-3.938h-3.938c-3.938 0-55.138 23.631-94.523 74.831-39.385 47.262-110.277 106.338-63.015 240.246 31.508 74.831 39.385 94.523-39.385 157.538 3.938-15.754 11.815-51.2 0-78.769-27.569-63.015-78.769-78.769-78.769-78.769s43.323 66.954 0 118.154c-39.385 43.323-55.138 129.969-35.446 200.862 15.754 59.077 70.892 106.338 157.538 137.846-7.877-3.938 110.277 43.323 244.185 3.938 59.077-19.692 137.846-43.323 185.108-106.338 39.385-51.2 74.831-129.969 39.385-196.923v0 0z\"></path> <path fill=\"#ed1e24\" d=\"M551.385 827.077h-78.769v-78.769h78.769v78.769zM551.385 708.923h-78.769v-275.692h78.769v275.692z\"></path> </svg>';\n\tconst clearedIcon = '<svg id=\"icon-alertsCleared-26\" viewBox=\"0 0 1024 1024\"> <title>Cleared</title> <path fill=\"#81ae49\" d=\"M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z\"></path> <path fill=\"white\" d=\"M866.462 669.538l-275.692-433.231c-43.323-70.892-114.215-70.892-157.538 0l-275.692 433.231c-43.323 70.892-3.938 157.538 78.769 157.538h551.385c82.708 0 122.092-86.646 78.769-157.538v0 0z\"></path> </svg>';\n\n\t// Call the function to populate the dashboard list...\n\tpopulateDashboardList();\n\t\n\t// Set a timer to refresh the table on a regular basis...\n\tif (fetchGroupAlertStatus) {\n\t\tconst dataRefresher = setInterval(function() {\n\t\t\t// populateDashboardList();\n\t\t\trefreshGroupStatus();\n\t\t\tconsole.log(\"Dynamic dashboard list refreshed.\");\n\t\t}, statusUpdateIntervalMinutes*1000*60);\n\t};\n\t\n\n\t// ----- FUNCTIONS\n\t\n\t/**\n\t* Fetches a Cross-Site Request Forgery (CSRF) token required for subsequent API calls.\n\t*\n\t* This function makes a preliminary request to a dummy endpoint solely to retrieve\n\t* the CSRF token from the response headers.\n\t*\n\t* @async\n\t* @function fetchCsrfToken\n\t* @returns {Promise<string>} A promise that resolves with the CSRF token.\n\t* @throws {Error} If the fetch request fails or the token is not found in headers.\n\t*/\n\tasync function fetchCsrfToken() {\n\t\t// console.debug('Fetching CSRF token...');\n\t\tconst response = await fetch('/santaba/rest/functions/dummy', {\n\t\t\tmethod: 'GET',\n\t\t\theaders: {\n\t\t\t\t'X-Csrf-Token': 'Fetch', // Specific header to request the token\n\t\t\t\t'Accept': 'application/json',\n\t\t\t\t'X-Version': '3', // Specify API version if required by this endpoint\n\t\t\t},\n\t\t\tcredentials: 'include', // Include cookies for session management/CSRF\n\t\t});\n\t\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`Failed to fetch CSRF token: ${response.status} ${response.statusText}`);\n\t\t}\n\t\n\t\tconst token = response.headers.get('X-Csrf-Token');\n\t\tif (!token) {\n\t\t\tthrow new Error('CSRF token not found in response headers.');\n\t\t}\n\t\t// console.debug('CSRF Token fetched successfully.');\n\t\t\n\t\treturn token;\n\t}\n\t\n\t/**\n\t\t* Performs an HTTP request to the LogicMonitor REST API.\n\t\t*\n\t\t* This function handles fetching a CSRF token, constructing the API request,\n\t\t* sending the request, and processing the response. It supports common HTTP verbs\n\t\t* and automatically includes necessary headers and credentials.\n\t\t*\n\t\t* @async\n\t\t* @function LMClient\n\t\t* @param {object} options - The options for the API request.\n\t\t* @param {string} options.resourcePath - The specific API resource path (e.g., /device/devices).\n\t\t* @param {string} [options.queryParams=''] - Optional query parameters string (e.g., ?filter=name:value).\n\t\t* @param {'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'} options.httpVerb - The HTTP method to use.\n\t\t* @param {object | Array<unknown>} [options.postBody] - The JSON payload for POST/PUT/PATCH requests.\n\t\t* @param {string} [options.apiVersion='3'] - The API version to use. Default is \"3\".\n\t\t* @returns {Promise<object>} A promise that resolves with the JSON response body on success.\n\t\t* @throws {Error} Throws an Error on API errors (>=300 status), network issues,\n\t\t*                 token fetching problems, or JSON handling errors. The error object\n\t\t*                 may contain 'status' and 'statusText' properties for API errors.\n\t*/\n\tasync function LMClient({\n\t\tresourcePath,\n\t\tqueryParams = '', // Default queryParams to empty string\n\t\thttpVerb,\n\t\tpostBody,\n\t\tapiVersion = '3',\n\t}) {\n\t\tconsole.debug('LMClient called with:', { resourcePath, queryParams, httpVerb, postBody, apiVersion });\n\t\t// Validate required parameters\n\t\tif (!resourcePath || !httpVerb) {\n\t\t\tthrow new Error('Missing required parameters: resourcePath and httpVerb must be provided.');\n\t\t}\n\t\tconst validVerbs = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];\n\t\tif (!validVerbs.includes(httpVerb)) {\n\t\t\tthrow new Error(`Invalid httpVerb: ${httpVerb}. Must be one of ${validVerbs.join(', ')}`);\n\t\t}\n\t\n\t\tconsole.debug(`Initiating LogicMonitor API call: ${httpVerb} ${resourcePath}${queryParams}`);\n\t\n\t\ttry {\n\t\t\t// 1. Fetch the CSRF token\n\t\t\tconst csrfToken = await fetchCsrfToken();\n\t\n\t\t\t// 2. Construct the API URL and request options\n\t\t\tconst apiUrl = `/santaba/rest${resourcePath}${queryParams}`;\n\t\t\tconst headers = {\n\t\t\t\t'Content-Type': 'application/json', // Consistently set Content-Type\n\t\t\t\t'Accept': 'application/json', // Expect JSON response\n\t\t\t\t'X-Csrf-Token': csrfToken,\n\t\t\t\t'X-Version': apiVersion, // Use the appropriate API version for the main request\n\t\t\t};\n\t\n\t\t\tconst requestOptions = {\n\t\t\t\tmethod: httpVerb,\n\t\t\t\theaders: headers,\n\t\t\t\tcredentials: 'include', // Necessary for session/cookie-based auth\n\t\t\t};\n\t\n\t\t\t// 3. Add body only for relevant methods\n\t\t\tif (postBody && (httpVerb === 'POST' || httpVerb === 'PUT' || httpVerb === 'PATCH')) {\n\t\t\t\ttry {\n\t\t\t\t\trequestOptions.body = JSON.stringify(postBody);\n\t\t\t\t\tconsole.debug('Request body included:', postBody);\n\t\t\t\t} catch (stringifyError) {\n\t\t\t\t\tconsole.error('Failed to stringify postBody:', stringifyError);\n\t\t\t\t\t// Add user-friendly message to the error\n\t\t\t\t\tstringifyError.message = `Invalid postBody provided. Could not stringify to JSON. Original error: ${stringifyError.message}`;\n\t\t\t\t\tthrow stringifyError;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 4. Make the API call\n\t\t\tconsole.debug(`Executing fetch to: ${apiUrl}`);\n\t\t\tconst response = await fetch(apiUrl, requestOptions);\n\t\t\tconsole.debug(`Received response status: ${response.status} ${response.statusText}`);\n\t\n\t\t\t// 5. Process the response\n\t\t\tif (response.ok) { // ok is true for statuses 200-299\n\t\t\t\t// Handle potential empty response body for certain success statuses (e.g., 204 No Content)\n\t\t\t\tif (response.status === 204) {\n\t\t\t\t\tconsole.debug('Received 204 No Content response.');\n\t\t\t\t\treturn {}; // Return an empty object for 204\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Assume response is JSON if status is ok and not 204\n\t\t\t\t\tconst data = await response.json();\n\t\t\t\t\tconsole.debug('API call successful, response data received.'); // Avoid logging potentially sensitive data by default\n\t\t\t\t\treturn data;\n\t\t\t\t} catch (jsonError) {\n\t\t\t\t\tconsole.error('Failed to parse JSON response:', jsonError);\n\t\t\t\t\t// Create a new error with more context\n\t\t\t\t\tconst parseError = new Error(`Successfully received response (${response.status}), but failed to parse JSON body. Original error: ${jsonError.message}`);\n\t\t\t\t\tparseError.status = response.status; // Attach status for context\n\t\t\t\t\tparseError.statusText = response.statusText;\n\t\t\t\t\tthrow parseError;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle API errors (status >= 300)\n\t\t\t\tconst error = new Error(`API Error: ${response.status} ${response.statusText}`);\n\t\t\t\terror.status = response.status;\n\t\t\t\terror.statusText = response.statusText;\n\t\n\t\t\t\t// Attempt to get more details from the error response body\n\t\t\t\ttry {\n\t\t\t\t\tconst errorBody = await response.text(); // Use text first in case it's not JSON\n\t\t\t\t\terror.body = errorBody || 'No additional error details provided.'; // Attach body to error\n\t\t\t\t\tconsole.warn(`API Error Body: ${error.body}`); // Log the raw error body\n\t\t\t\t} catch (bodyError) {\n\t\t\t\t\tconsole.warn('Could not read error response body:', bodyError);\n\t\t\t\t\terror.body = 'Could not read error response body.';\n\t\t\t\t}\n\t\t\t\tconsole.error('LogicMonitor API Error:', { status: error.status, statusText: error.statusText });\n\t\t\t\tthrow error; // Throw the augmented error object\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Catch errors from fetchCsrfToken, fetch itself (network errors), or JSON parsing/stringifying\n\t\t\tconsole.error('An error occurred in LMClient:', error.message || error);\n\t\n\t\t\t// Re-throw the error to be handled by the caller.\n\t\t\t// Ensure it's always an Error object.\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t} else {\n\t\t\t\t// If it's not an Error object (e.g., the thrown API error object), wrap it\n\t\t\t\tconst wrappedError = new Error(error.message || 'An unexpected error occurred during the API call.');\n\t\t\t\t// Copy relevant properties if they exist\n\t\t\t\tif (error && typeof error === 'object') {\n\t\t\t\t\tif ('status' in error) wrappedError.status = error.status;\n\t\t\t\t\tif ('statusText' in error) wrappedError.statusText = error.statusText;\n\t\t\t\t\tif ('body' in error) wrappedError.body = error.body;\n\t\t\t\t}\n\t\t\t\tthrow wrappedError;\n\t\t\t};\n\t\t};\n\t};\n\n\t// Removes duplicate values from an array...\n\tfunction removeDuplicates(arr) {\n\t\tlet obj = {};\n\t\tlet ret_arr = [];\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tobj[arr[i]] = true;\n\t\t}\n\t\tfor (let key in obj) {\n\t\t\tret_arr.push(key);\n\t\t}\n\t\treturn ret_arr;\n\t}\n\n\t// Function for retrieving a list of groups from LogicMonitor and populating the appropriate drop-down...\n\tasync function populateDashboardList() {\n\t\t// Reset our list in the widget...\n\t\tdynamicTable.innerHTML = \"\";\n\t\t\n\t\tlet sortBy = \"name\";\n\t\tif (showFullPath) {\n\t\t\tsortBy = \"fullPath\";\n\t\t};\n\t\t\n\t\t// API request details...\n\t\tlet httpVerb = \"GET\";\n\t\tlet resourcePath = \"/dashboard/groups\";\n\t\tlet queryParams = \"\";\n\t\tif (defaultDashboardGroupValue == \"\\#\\#defaultDashboardGroup\\#\\#\") {\n\t\t\tqueryParams = `?sort=${sortBy}&size=${maxGroups}&filter=numOfDashboards>0`;\n\t\t} else {\n\t\t\tqueryParams = `?sort=${sortBy}&size=${maxGroups}&filter=fullPath~\"${defaultDashboardGroupValue}\",numOfDashboards>0`;\n\t\t};\n\n\t\tconsole.log(\"Fetching the dashboard list...\");\n\t\t// Call the LogicMonitor API to get a list of dashboards...\n\t\tconst data = await LMClient({\n\t\t\tresourcePath: resourcePath,\n\t\t\tqueryParams: queryParams,\n\t\t\thttpVerb: httpVerb,\n\t\t\tpostBody: null,\n\t\t\tapiVersion: '3',\n\t\t});\n\t\t// console.debug('Dashboard Group request succeeded with JSON response', data);\n\n\t\t// Start populating the table...\n\t\tdata.items.forEach(thisItem => {\n\t\t\t// Test whether to list this dashboard...\n\t\t\tlet proceed = true;\n\t\t\tif (thisItem.fullPath == \"\") {\n\t\t\t\tproceed = false;\n\t\t\t}\n\t\t\t// if (exclusionRE != \"\" && exclusionRE.test(thisItem.name)) {\n\t\t\tif (exclusionRE != \"\" && exclusionRE.test(thisItem.fullPath)) {\n\t\t\t\tproceed = false;\n\t\t\t}\n\t\t\t\n\t\t\tlet groupTitle = thisItem.fullPath;\n\t\t\tif (!showFullPath) {\n\t\t\t\tgroupTitle = thisItem.name;\n\t\t\t};\n\n\t\t\tif (proceed) {\n\t\t\t\tlet tmpRowID = \"dashRow\" + thisItem.id;\n\t\t\t\tlet dashGroupToken = \"\";\n\n\t\t\t\t// Look to see if the dashboard group has a 'defaultResourceGroup' token set...\n\t\t\t\tif (thisItem.widgetTokens.length > 0) {\n\t\t\t\t\tthisItem.widgetTokens.forEach(thisToken => {\n\t\t\t\t\t\tif (thisToken.name == \"defaultResourceGroup\") {\n\t\t\t\t\t\t\tdashGroupToken = thisToken.value;\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\t// If a 'defaultResourceGroup' token was found...\n\t\t\t\t\tif (dashGroupToken != \"\") {\n\t\t\t\t\t\t// Capture the 'defaultResourceGroup' value in a data element attached to the HTML row...\n\t\t\t\t\t\tresourceGroups.push(dashGroupToken);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t// Create an HTML element where we'll be constructing our content...\n\t\t\t\tconst dashboardNode = document.createElement(\"div\");\n\t\t\t\tdashboardNode.classList.add(\"dashboardItem\");\n\t\t\t\tdashboardNode.dataset.groupname = dashGroupToken;\n\t\t\t\t\n\t\t\t\t// Create an HTML element to hold the dashboard group info & list...\n\t\t\t\tlet content = `<div><div class=\"groupName\">${groupTitle}</div><ul id=\"${tmpRowID}\">`;\n\t\t\t\t\n\t\t\t\t// List the group's dashboards...\n\t\t\t\tif (thisItem.numOfDirectDashboards > 0) {\n\t\t\t\t\tthisItem.dashboards.forEach(thisDash => {\n\t\t\t\t\t\tlet pathName = \"santaba/uiv4/dashboards/dashboards-\" + thisDash.id;\n\t\t\t\t\t\tcontent = `${content}<li class=\"dashboardListItem\"><a href=\"${window.location.origin}/${pathName}\" target=\"_parent\">${thisDash.name}</a></li>`;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\t// Close out the first cell...\n\t\t\t\tcontent = content + \"</ul></div>\";\n\t\t\t\t\n\t\t\t\t// Make a cell for the alert icon (if applicable)...\n\t\t\t\tif (fetchGroupAlertStatus) {\n\t\t\t\t\tcontent = `${content}<div class=\"dashboardListGroupStatus\"></div>`\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t// Add our content to the widget...\n\t\t\t\tdashboardNode.innerHTML = content;\n\t\t\t\tdynamicTable.appendChild(dashboardNode);\n\t\t\t};\n\t\t});\n\n\t\t// If any of the groups had a 'defaultResourceGroup' token set...\n\t\tif (fetchGroupAlertStatus && resourceGroups.length > 0) {\n\t\t\t// First, let's deduplicate the list...\n\t\t\tresourceGroups = removeDuplicates(resourceGroups);\n\n\t\t\t// Fetch the current alert status of the resource groups...\n\t\t\t// resourceGroups.forEach(thisGroup => {\n\t\t\t// \tlet groupInfo = getResourceGroupStatus(thisGroup);\n\t\t\t// });\n\t\t\trefreshGroupStatus();\n\t\t};\n\t};\n\t\n\tfunction refreshGroupStatus() {\n\t\tif (fetchGroupAlertStatus && resourceGroups.length > 0) {\n\t\t\t// Fetch the current alert status of the resource groups...\n\t\t\tresourceGroups.forEach(thisGroup => {\n\t\t\t\tlet groupInfo = getResourceGroupStatus(thisGroup);\n\t\t\t});\n\t\t};\n\t};\n\n\t// Function for getting status of the resource group based on 'defaultResourceGroup' tokens...\n\tasync function getResourceGroupStatus(resourceGroup) {\n\t\tlet encodedResourceGroup = encodeURIComponent(resourceGroup);\n\n\t\t// API request details...\n\t\tlet httpVerb = \"GET\";\n\t\tlet epoch = (new Date).getTime();\n\t\tlet resourcePath = \"/device/groups\";\n\t\tlet queryParams = '?size=' + maxGroups + '&filter=fullPath:\"' + encodedResourceGroup + '\"&fields=id,fullPath,alertStatus,sdtStatus,alertDisableStatus,disableAlerting';\n\n\t\t// console.debug(\"Fetching resource group status for \" + resourceGroup + \"...\");\n\n\t\ttry {\n\t\t\tconst data = await LMClient({\n\t\t\t\tresourcePath: resourcePath,\n\t\t\t\tqueryParams: queryParams,\n\t\t\t\thttpVerb: httpVerb,\n\t\t\t\tpostBody: null,\n\t\t\t\tapiVersion: '3',\n\t\t\t});\n\t\n\t\t\t// console.log('Resource Group request succeeded with JSON response', data)\n\t\n\t\t\tif (data.total != 0) {\n\t\t\t\tlet highestSeverity = \"clear\";\n\t\n\t\t\t\tdata.items.forEach(thisItem => {\n\t\t\t\t\t// console.log(thisItem.alertStatus)\n\t\t\t\t\tlet alertStatusArray = thisItem.alertStatus.match(/([\\w]+)-([\\w]+)-([\\w]+)/);\n\t\t\t\t\t// console.log(\"alertStatusArray for \" + resourceGroup + \": \" + alertStatusArray)\n\t\t\t\t\tif (alertStatusArray) {\n\t\t\t\t\t\tlet alertStatus = alertStatusArray[1];\n\t\t\t\t\t\tlet alertSeverity = alertStatusArray[2];\n\t\n\t\t\t\t\t\tif ((alertSeverity == \"warn\" && highestSeverity == \"\") || (alertSeverity == \"error\" && highestSeverity != \"critical\") || (alertSeverity == \"critical\")) {\n\t\t\t\t\t\t\thighestSeverity = alertSeverity;\n\t\t\t\t\t\t\t// console.log(\"highestSeverity for \" + resourceGroup + \" is \" + highestSeverity)\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t});\n\t\n\t\t\t\t// Remove previous severity classes from the row...\n\t\t\t\tconst tmpRow = document.querySelector(\"#dashboardListContainer > [data-groupname='\" + resourceGroup + \"']\");\n\t\t\t\ttmpRow.classList.remove(\"clear\", \"warn\", \"error\", \"critical\");\n\t\t\t\t\n\t\t\t\tlet sevIcon = clearedIcon;\n\t\t\t\tif (highestSeverity != \"clear\") {\n\t\t\t\t\tif (highestSeverity == \"warn\") {\n\t\t\t\t\t\tsevIcon = warningIcon;\n\t\t\t\t\t} else if (highestSeverity == \"error\") {\n\t\t\t\t\t\tsevIcon = errorIcon;\n\t\t\t\t\t} else if (highestSeverity == \"critical\") {\n\t\t\t\t\t\tsevIcon = criticalIcon;\n\t\t\t\t\t};\n\t\t\t\t\ttmpRow.classList.add(highestSeverity);\n\t\t\t\t} else {\n\t\t\t\t\ttmpRow.classList.add(\"clear\");\n\t\t\t\t};\n\t\n\t\t\t\t// Add the severity class/icon to the appropriate places in the HTML table...\n\t\t\t\tdocument.querySelector(\"#dashboardListContainer > [data-groupname='\" + resourceGroup + \"'] div.dashboardListGroupStatus\").innerHTML = sevIcon;\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.error('Error fetching data:', error);\n\t\t};\n\t}\n</script>"
      }
    },
    {
      "position": {
        "col": 4,
        "sizex": 9,
        "row": 1,
        "sizey": 7
      },
      "config": {
        "displaySettings": {},
        "isSupportCustomProperty": false,
        "supportCustomProperty": false,
        "name": "README - Dynamic Dashboard List",
        "description": "",
        "theme": "newSolidBlue",
        "interval": 15,
        "type": "text",
        "timescale": "day",
        "version": 2,
        "content": "<p>This script was created in response to a customer needing a quick way to drill-down from an overview dashboard to various specific dashboards. While straightforward to manually make a list in a text widget, we wanted a way to dynamically list dashboards as they were added or changed. To further enhance the functionality, if a &#39;defaultResourceGroup&#39; token is set on a dashboard group then the script will fetch current alert status for that group (can be disabled via the &#39;fetchGroupAlertStatus&#39; variable in the script if API limits are an issue).</p><p>NOTE: while this script leverages standard LogicMonitor APIs and features, this script itself is not officially supported by LogicMonitor.</p><p>There are a few dashboard tokens containing information that the Resource Selector will use:</p><h3>Optional Tokens:</h3><ul><li><strong>ShowFullDashboardPath</strong>: (optional) Whether to show the dashboard group&#39;s full path instead of its short name. Default: true.</li><li><strong>defaultDashboardGroup</strong>: (optional) The &quot;parent&quot; dashboard group you want to list dashboards under. If not set then the script will default to showing all dashboard groups.</li><li><strong>dashboardsToExclude</strong>: (optional) A regular expression of any dashboards (by name) you want to exclude. Example: &quot;.[Tt]+emplate.&quot;</li></ul><p><br></p><p>For instance, this dashboard&#39;s current tokens are:</p><ul><li><strong>defaultDashboardGroup</strong>: &quot;<pre style=\"display: inline-block;\">##defaultDashboardGroup##</pre>&quot;</li><li><strong>DashboardsToExclude</strong>: &quot;<pre style=\"display: inline-block;\">##DashboardsToExclude##</pre>&quot;</li><li><strong>ShowFullDashboardPath</strong>: &quot;<pre style=\"display: inline-block;\">##ShowFullDashboardPath##</pre>&quot;</li></ul>"
      }
    }
  ],
  "version": 2
}