<!--
	Better Map Widget (Leaflet Version)
	Version 4.0
	Developed by Kevin Ford

	Some of the ideas behind this project:
	* Support for thousands pins on the map using Leaflet's efficient rendering.
	* Adjacent pins get grouped/clustered together for a cleaner map display.
	* Clusters use a donut chart to represent the severities of the grouped markers.
	* Easy toggling of weather layers.
	* Display more information when clicking a marker.
	* Quick & easy filtering of what's displayed on the map.
	* Provide a way to plot connections between resources (and eventually groups).

	Prerequisites:
	* The user needs "View" permissions to the dashboard plus any displayed groups and/or resources.
	* Group's or resources with valid addresses set in the usual 'location' property.

	TO USE:
	1. Create a new Text widget to the dashboard.
	2. On the Text widget's edit dialog, click the "Source" button and paste in the contents of this script, then save the widget.
	3. At this point the widget should be ready to use. You can customize the defaults for the widget either via dashboard tokens or by changing variables here within the script.
	   For instance, the script defaults to using "*" for the group filter. You can change the default by setting a "MapGroupPathFilter" dashboard token, or by hard-coding it in the script's "groupPathFilter" variable below.
	   NOTE: defaults set via dashboard tokens will take precedence over those hard-coded in the script.

	OPTIONAL DASHBOARD TOKENS:
	* 'MapGroupPathFilter': Allows setting a default group path to start. Default is "*".
	* 'MapShowWeather': If weather should be shown by default. Options are "global" or "nexrad". Default is "global".
	* 'MapOverlayOption': Which optional overlay to default to when weather is shown. Options are "wildfires", "us-wildfires", "outages", "us-poweroutages", "us-flooding", "earthquakes", "hurricanes", or "air-quality". Default is "earthquakes".
	* 'HideMapOptions': If "true" then will hide the options bar by default. Default is "false".
	* 'MapSourceType': Whether to map "groups", "resources", or "services". Default is "groups".
	* 'MapIgnoreCleared': If "true" then will only show items currently alerting (useful for maps with thousands of markers). Default is "false".
	* 'MapIgnoreWarnings': If "true" then won't show items in "Warning" status. Default is "false".
	* 'MapIgnoreErrors': If "true" then won't show items in "Error" status. Default is "false".
	* 'MapIgnoreCriticals': If "true" then won't show items in "Critical" status. Default is "false".
	* 'MapIgnoreSDT': If "true" then won't show items in "SDT" status. Default is "false".
	* 'AutoResetMapOnRefresh': If "true" then the map will automatically zoom to encompass all items on timed refreshes. Default is "false".
	* 'MapDisableClustering': If "true" then clustering of adjacent markers on the map will be disabled. Might be desirable if showing connections between locations since clustering might hide markers at certain zoom levels. Default is "false".
	* 'MapDisplayProperties': An optional comma-delimited list of custom properties to show when viewing a group's/resource's details.
	* 'MapStyle': Allows one of the following available map style options: "silver", "standard", "dark", "aubergine", or "silverblue". Default is "silverblue".

	LIMITATIONS:
	* This widget is currently unable to leverage LogicMonitor's native dashboard filters.
	* Being custom-developed, LogicMonitor's support teams will be limited in what they can assist with regarding questions/issues.
-->

<!-- Leaflet CSS (embedded to ensure it loads in widget environments) -->
<style>
/* Leaflet 1.9.4 Core CSS */
.leaflet-pane,
.leaflet-tile,
.leaflet-marker-icon,
.leaflet-marker-shadow,
.leaflet-tile-container,
.leaflet-pane > svg,
.leaflet-pane > canvas,
.leaflet-zoom-box,
.leaflet-image-layer,
.leaflet-layer {
	position: absolute;
	left: 0;
	top: 0;
}
.leaflet-container {
	overflow: hidden;
}
.leaflet-tile,
.leaflet-marker-icon,
.leaflet-marker-shadow {
	-webkit-user-select: none;
	-moz-user-select: none;
	user-select: none;
	-webkit-user-drag: none;
}
.leaflet-tile::selection {
	background: transparent;
}
.leaflet-safari .leaflet-tile {
	image-rendering: -webkit-optimize-contrast;
}
.leaflet-safari .leaflet-tile-container {
	width: 1600px;
	height: 1600px;
	-webkit-transform-origin: 0 0;
}
.leaflet-marker-icon,
.leaflet-marker-shadow {
	display: block;
}
.leaflet-container .leaflet-overlay-pane svg {
	max-width: none !important;
	max-height: none !important;
}
.leaflet-container .leaflet-marker-pane img,
.leaflet-container .leaflet-shadow-pane img,
.leaflet-container .leaflet-tile-pane img,
.leaflet-container img.leaflet-image-layer,
.leaflet-container .leaflet-tile {
	max-width: none !important;
	max-height: none !important;
	width: auto;
	padding: 0;
}
.leaflet-container.leaflet-touch-zoom {
	-ms-touch-action: pan-x pan-y;
	touch-action: pan-x pan-y;
}
.leaflet-container.leaflet-touch-drag {
	-ms-touch-action: pinch-zoom;
	touch-action: none;
	touch-action: pinch-zoom;
}
.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {
	-ms-touch-action: none;
	touch-action: none;
}
.leaflet-container {
	-webkit-tap-highlight-color: transparent;
}
.leaflet-container a {
	-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);
}
.leaflet-tile {
	filter: inherit;
	visibility: hidden;
}
.leaflet-tile-loaded {
	visibility: inherit;
}
.leaflet-zoom-box {
	width: 0;
	height: 0;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
	z-index: 800;
}
.leaflet-overlay-pane svg {
	-moz-user-select: none;
}
.leaflet-pane { z-index: 400; }
.leaflet-tile-pane { z-index: 200; }
.leaflet-overlay-pane { z-index: 400; }
.leaflet-shadow-pane { z-index: 500; }
.leaflet-marker-pane { z-index: 600; }
.leaflet-tooltip-pane { z-index: 650; }
.leaflet-popup-pane { z-index: 700; }
.leaflet-map-pane canvas { z-index: 100; }
.leaflet-map-pane svg { z-index: 200; }
.leaflet-vml-shape {
	width: 1px;
	height: 1px;
}
.lvml {
	behavior: url(#default#VML);
	display: inline-block;
	position: absolute;
}
.leaflet-control {
	position: relative;
	z-index: 800;
	pointer-events: visiblePainted;
	pointer-events: auto;
}
.leaflet-top,
.leaflet-bottom {
	position: absolute;
	z-index: 1000;
	pointer-events: none;
}
.leaflet-top { top: 0; }
.leaflet-right { right: 0; }
.leaflet-bottom { bottom: 0; }
.leaflet-left { left: 0; }
.leaflet-control {
	float: left;
	clear: both;
}
.leaflet-right .leaflet-control {
	float: right;
}
.leaflet-top .leaflet-control {
	margin-top: 10px;
}
.leaflet-bottom .leaflet-control {
	margin-bottom: 10px;
}
.leaflet-left .leaflet-control {
	margin-left: 10px;
}
.leaflet-right .leaflet-control {
	margin-right: 10px;
}
.leaflet-fade-anim .leaflet-popup {
	opacity: 0;
	-webkit-transition: opacity 0.2s linear;
	-moz-transition: opacity 0.2s linear;
	transition: opacity 0.2s linear;
}
.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
	opacity: 1;
}
.leaflet-zoom-animated {
	-webkit-transform-origin: 0 0;
	-ms-transform-origin: 0 0;
	transform-origin: 0 0;
}
svg.leaflet-zoom-animated {
	will-change: transform;
}
.leaflet-zoom-anim .leaflet-zoom-animated {
	-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);
	-moz-transition: -moz-transform 0.25s cubic-bezier(0,0,0.25,1);
	transition: transform 0.25s cubic-bezier(0,0,0.25,1);
}
.leaflet-zoom-anim .leaflet-tile,
.leaflet-pan-anim .leaflet-tile {
	-webkit-transition: none;
	-moz-transition: none;
	transition: none;
}
.leaflet-zoom-anim .leaflet-zoom-hide {
	visibility: hidden;
}
.leaflet-interactive {
	cursor: pointer;
}
.leaflet-grab {
	cursor: -webkit-grab;
	cursor: -moz-grab;
	cursor: grab;
}
.leaflet-crosshair,
.leaflet-crosshair .leaflet-interactive {
	cursor: crosshair;
}
.leaflet-popup-pane,
.leaflet-control {
	cursor: auto;
}
.leaflet-dragging .leaflet-grab,
.leaflet-dragging .leaflet-grab .leaflet-interactive,
.leaflet-dragging .leaflet-marker-draggable {
	cursor: move;
	cursor: -webkit-grabbing;
	cursor: -moz-grabbing;
	cursor: grabbing;
}
.leaflet-marker-icon,
.leaflet-marker-shadow,
.leaflet-image-layer,
.leaflet-pane > svg path,
.leaflet-tile-container {
	pointer-events: none;
}
.leaflet-marker-icon.leaflet-interactive,
.leaflet-image-layer.leaflet-interactive,
.leaflet-pane > svg path.leaflet-interactive,
svg.leaflet-image-layer.leaflet-interactive path {
	pointer-events: visiblePainted;
	pointer-events: auto;
}
.leaflet-container {
	background: #ddd;
	outline-offset: 1px;
}
.leaflet-container a {
	color: #0078A8;
}
.leaflet-zoom-box {
	border: 2px dotted #38f;
	background: rgba(255,255,255,0.5);
}
.leaflet-container {
	font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
	font-size: 12px;
	font-size: .75rem;
	line-height: 1.5;
}
.leaflet-bar {
	box-shadow: 0 1px 5px rgba(0,0,0,0.65);
	border-radius: 4px;
}
.leaflet-bar a {
	background-color: #fff;
	border-bottom: 1px solid #ccc;
	width: 26px;
	height: 26px;
	line-height: 26px;
	display: block;
	text-align: center;
	text-decoration: none;
	color: black;
}
.leaflet-bar a,
.leaflet-control-layers-toggle {
	background-position: 50% 50%;
	background-repeat: no-repeat;
	display: block;
}
.leaflet-bar a:hover,
.leaflet-bar a:focus {
	background-color: #f4f4f4;
}
.leaflet-bar a:first-child {
	border-top-left-radius: 4px;
	border-top-right-radius: 4px;
}
.leaflet-bar a:last-child {
	border-bottom-left-radius: 4px;
	border-bottom-right-radius: 4px;
	border-bottom: none;
}
.leaflet-bar a.leaflet-disabled {
	cursor: default;
	background-color: #f4f4f4;
	color: #bbb;
}
.leaflet-touch .leaflet-bar a {
	width: 30px;
	height: 30px;
	line-height: 30px;
}
.leaflet-touch .leaflet-bar a:first-child {
	border-top-left-radius: 2px;
	border-top-right-radius: 2px;
}
.leaflet-touch .leaflet-bar a:last-child {
	border-bottom-left-radius: 2px;
	border-bottom-right-radius: 2px;
}
.leaflet-control-zoom-in,
.leaflet-control-zoom-out {
	font: bold 18px 'Lucida Console', Monaco, monospace;
	text-indent: 1px;
}
.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out {
	font-size: 22px;
}
.leaflet-control-layers {
	box-shadow: 0 1px 5px rgba(0,0,0,0.4);
	background: #fff;
	border-radius: 5px;
}
.leaflet-control-layers-toggle {
	width: 36px;
	height: 36px;
}
.leaflet-touch .leaflet-control-layers-toggle {
	width: 44px;
	height: 44px;
}
.leaflet-control-layers .leaflet-control-layers-list,
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {
	display: none;
}
.leaflet-control-layers-expanded .leaflet-control-layers-list {
	display: block;
	position: relative;
}
.leaflet-control-layers-expanded {
	padding: 6px 10px 6px 6px;
	color: #333;
	background: #fff;
}
.leaflet-control-layers-scrollbar {
	overflow-y: scroll;
	overflow-x: hidden;
	padding-right: 5px;
}
.leaflet-control-layers-selector {
	margin-top: 2px;
	position: relative;
	top: 1px;
}
.leaflet-control-layers label {
	display: block;
	font-size: 13px;
	font-size: .8125rem;
}
.leaflet-control-layers-separator {
	height: 0;
	border-top: 1px solid #ddd;
	margin: 5px -10px 5px -6px;
}
.leaflet-container .leaflet-control-attribution {
	background: #fff;
	background: rgba(255, 255, 255, 0.8);
	margin: 0;
}
.leaflet-control-attribution,
.leaflet-control-scale-line {
	padding: 0 5px;
	color: #333;
	line-height: 1.4;
}
.leaflet-control-attribution a {
	text-decoration: none;
}
.leaflet-control-attribution a:hover,
.leaflet-control-attribution a:focus {
	text-decoration: underline;
}
.leaflet-left .leaflet-control-scale {
	margin-left: 5px;
}
.leaflet-bottom .leaflet-control-scale {
	margin-bottom: 5px;
}
.leaflet-control-scale-line {
	border: 2px solid #777;
	border-top: none;
	line-height: 1.1;
	padding: 2px 5px 1px;
	white-space: nowrap;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
	background: rgba(255, 255, 255, 0.8);
	text-shadow: 1px 1px #fff;
}
.leaflet-control-scale-line:not(:first-child) {
	border-top: 2px solid #777;
	border-bottom: none;
	margin-top: -2px;
}
.leaflet-control-scale-line:not(:first-child):not(:last-child) {
	border-bottom: 2px solid #777;
}
.leaflet-touch .leaflet-control-attribution,
.leaflet-touch .leaflet-control-layers,
.leaflet-touch .leaflet-bar {
	box-shadow: none;
}
.leaflet-touch .leaflet-control-layers,
.leaflet-touch .leaflet-bar {
	border: 2px solid rgba(0,0,0,0.2);
	background-clip: padding-box;
}
.leaflet-popup {
	position: absolute;
	text-align: center;
	margin-bottom: 20px;
}
.leaflet-popup-content-wrapper {
	padding: 1px;
	text-align: left;
	border-radius: 12px;
}
.leaflet-popup-content {
	margin: 13px 24px 13px 20px;
	line-height: 1.3;
	font-size: 13px;
	font-size: .8125rem;
	min-height: 1px;
}
.leaflet-popup-content p {
	margin: 17px 0;
	margin: 1.3em 0;
}
.leaflet-popup-tip-container {
	width: 40px;
	height: 20px;
	position: absolute;
	left: 50%;
	margin-top: -1px;
	margin-left: -20px;
	overflow: hidden;
	pointer-events: none;
}
.leaflet-popup-tip {
	width: 17px;
	height: 17px;
	padding: 1px;
	margin: -10px auto 0;
	pointer-events: auto;
	-webkit-transform: rotate(45deg);
	-moz-transform: rotate(45deg);
	-ms-transform: rotate(45deg);
	transform: rotate(45deg);
}
.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
	background: white;
	color: #333;
	box-shadow: 0 3px 14px rgba(0,0,0,0.4);
}
.leaflet-container a.leaflet-popup-close-button {
	position: absolute;
	top: 0;
	right: 0;
	border: none;
	text-align: center;
	width: 24px;
	height: 24px;
	font: 16px/24px Tahoma, Verdana, sans-serif;
	color: #757575;
	text-decoration: none;
	background: transparent;
}
.leaflet-container a.leaflet-popup-close-button:hover,
.leaflet-container a.leaflet-popup-close-button:focus {
	color: #585858;
}
.leaflet-popup-scrolled {
	overflow: auto;
}
.leaflet-div-icon {
	background: #fff;
	border: 1px solid #666;
}
.leaflet-tooltip {
	position: absolute;
	padding: 6px;
	background-color: #fff;
	border: 1px solid #fff;
	border-radius: 3px;
	color: #222;
	white-space: nowrap;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	pointer-events: none;
	box-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
.leaflet-tooltip.leaflet-interactive {
	cursor: pointer;
	pointer-events: auto;
}
.leaflet-tooltip-top:before,
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
	position: absolute;
	pointer-events: none;
	border: 6px solid transparent;
	background: transparent;
	content: "";
}
.leaflet-tooltip-bottom { margin-top: 6px; }
.leaflet-tooltip-top { margin-top: -6px; }
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-top:before {
	left: 50%;
	margin-left: -6px;
}
.leaflet-tooltip-top:before {
	bottom: 0;
	margin-bottom: -12px;
	border-top-color: #fff;
}
.leaflet-tooltip-bottom:before {
	top: 0;
	margin-top: -12px;
	margin-left: -6px;
	border-bottom-color: #fff;
}
.leaflet-tooltip-left { margin-left: -6px; }
.leaflet-tooltip-right { margin-left: 6px; }
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
	top: 50%;
	margin-top: -6px;
}
.leaflet-tooltip-left:before {
	right: 0;
	margin-right: -12px;
	border-left-color: #fff;
}
.leaflet-tooltip-right:before {
	left: 0;
	margin-left: -12px;
	border-right-color: #fff;
}

/* MarkerCluster CSS */
.marker-cluster-small {
	background-color: rgba(181, 226, 140, 0.6);
}
.marker-cluster-small div {
	background-color: rgba(110, 204, 57, 0.6);
}
.marker-cluster-medium {
	background-color: rgba(241, 211, 87, 0.6);
}
.marker-cluster-medium div {
	background-color: rgba(240, 194, 12, 0.6);
}
.marker-cluster-large {
	background-color: rgba(253, 156, 115, 0.6);
}
.marker-cluster-large div {
	background-color: rgba(241, 128, 23, 0.6);
}
.marker-cluster {
	background-clip: padding-box;
	border-radius: 20px;
}
.marker-cluster div {
	width: 30px;
	height: 30px;
	margin-left: 5px;
	margin-top: 5px;
	text-align: center;
	border-radius: 15px;
	font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
}
.marker-cluster span {
	line-height: 30px;
}
</style>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<!-- Leaflet MarkerCluster JS -->
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>


<script>
	// Whether we're plotting "groups" or "resources" or "services" (strongly recommend staying with groups or services)...
	// You can either set it here or in a dashboard token named 'MapSourceType'...
	let mapSourceType = "groups";

	// Preferred map style. Available options: "silver" (the default), "standard", "dark", "aubergine", or "silverblue"...
	let mapStyle = "silverblue";

	// Whether to ignore items with no active alerts (useful for maps with thousands of markers)...
	// You can either set it here or in a dashboard token named 'MapIgnoreCleared'...
	let showCleared = true;
	let showWarnings = true;
	let showErrors = true;
	let showCriticals = true;
	let showSDT = true;

	// Capture if a group filter...
	// You can set it here or in a dashboard token named "MapGroupPathFilter"...
	let groupPathFilter = "*";

	// Interval for updating group status data (in minutes)...
	let statusUpdateIntervalMinutes = 2;

	// Flag to disable marker clustering if needed...
	let disableClustering = false;

	// Whether to show weather by default. Options are: "no", "global", "nexrad"...
	// You can set it here or in a dashboard token named "MapShowWeather"...
	let showWeatherDefault = "no";

	// If weather is shown, whether to show "wildfires", "us-wildfires", "outages", "us-poweroutages", "us-flooding", "earthquakes", "hurricanes", or "air-quality"...
	// You can set it here or in a dashboard token named "MapOverlayOption"...
	let additionalOverlayOption = "earthquakes";

	// Whether to show or hide the map options along the top of the widget by default...
	// You can set it here or in a dashboard token named "HideMapOptions"...
	let hideMapOptionsByDefault = false;

	// Whether to automatically center the map to encompass all items during timed refreshes...
	// You can set it here or in a dashboard token named "AutoResetMapOnRefresh"...
	let autoResetMapOnRefresh = false;

	// When true will not refresh the data on a timed interval (useful ONLY during development)...
	let developmentFlag = false;

	// Since we generally don't need to poll all properties every time, we can just grab them initially then occasionally every x number of polls based on the following variable (set to 0 to perform a full refresh every time)...
	const fullRefreshInterval = 0;

	// Whether to include inherited locations in addition to those directly set on resources and/or services (disabling this can greatly increase refresh speed)...
	const pollInheritedLocations = true;

	// Typically if both a 'latitude' & 'longitude' property are set, then we can assume the address is already geocoded. Set this to "true" to force geocoding the address instead...
	const ignoreLatLongProps = false;

	// Whether Leaflet uses scroll wheel zoom (true = enabled, false = disabled requiring ctrl+scroll)...
	const scrollWheelZoom = true;

	// An optional comma-delimited list of custom properties to show when viewing a group's/resource's details...
	// You can set it here or in a dashboard token named "MapDisplayProperties"...
	let displayProps = "";

	// Property to look for connecting information in...
	const connectionInfoProp = "auto.custom_map_connection_data";
	// Stroke weight of connecting lines...
	const connectingLineWeight = 3;
	// Whether to use geodesic lines when connecting two locations (I recommend not so it just plots a straight line vs curve of the Earth)...
	const useGeodesicLines = false;

	// Default opacity for weather layers...
	const weatherOpacity = 0.22;
	// Weather refresh interval in minutes...
	const weatherRefreshMinutes = 5;
	// Whether to display details about a wildfire on "click" or "mouseover"...
	const showWildfireInfoEvent = "click";
	// Whether the opacity of an earthquake's icon reflects "time" since the event, or "magnitude"...
	let quakeMode = "time";
</script>

<!-- We'll use FontAwesome icons to help pretty up things... -->
<!-- <script src="https://use.fontawesome.com/releases/v6.2.0/js/all.js"></script> -->


<!-- Our CSS styles... -->
<style type="text/css">
	html, body {
		height: 100%;
		margin: 0;
		padding: 0;
	}
	body {
		margin-top: 0;
	}
	.customMapBody {
		display: flex;
		flex-direction: column;
		height: 100%;
		width: 100%;
		padding: 0;
		margin: 0;
		box-sizing: border-box;
	}
	#leafletMap {
		width: 100%;
		height: 100%;
		padding: 0;
		margin: 0;
		position: relative;
		overflow: hidden;
	}
	/* Leaflet adds .leaflet-container class to the map div itself */
	#leafletMap.leaflet-container {
		width: 100% !important;
		height: 100% !important;
	}
	/* Critical: Ensure tile panes and containers are properly positioned */
	#leafletMap .leaflet-map-pane {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
	}
	#leafletMap .leaflet-tile-pane {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
	}
	#leafletMap .leaflet-tile-container {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
	}
	#leafletMap .leaflet-tile {
		position: absolute !important;
	}
	/* Prevent any transitions from affecting Leaflet tile positioning */
	#leafletMap .leaflet-tile,
	#leafletMap .leaflet-tile-container,
	#leafletMap .leaflet-tile-pane,
	#leafletMap .leaflet-map-pane {
		transition: none !important;
		animation: none !important;
	}
	.optionsHidden * {
		max-height: 0;
		min-height: 0;
		transition: all 0.4s ease-out;
	}
	.optionsVisible * {
		max-height: unset;
		min-height: auto;
		transition: all 0.4s ease-out;
	}
	.optionsVisibleToggle {
		rotate: 0;
		transition: all 1s ease-out;
	}
	.optionsHiddenToggle {
		rotate: 180deg;
		transition: all 1s ease-out;
	}
	.mapInfoPopupWindow {
		color: rgb(20, 29, 48);
		padding: 0 12px 12px 12px;
		min-width: 300px;
		max-height: 400px;
		overflow-y: auto;
		font-family: system-ui, -apple-system, sans-serif;
	}
	#optionsBar {
		width: 100%;
		/* min-height: 25px; */
		padding: 3px 0 0 0;
		margin: 0;
		font-size: small;
		color: #777;
		order: 1;
		display: flex;
		flex-wrap: nowrap;
		flex: none;
		align-items: center;
	}
	#leafletMap {
		order: 2;
		flex: 1;
		border: 1px solid #aaa;
		border-radius: 7px;
		z-index: 0;
		min-height: 300px;
	}
	#customMapRefreshButton, #customMapResetZoom {
		margin-right: 5px;
	}
	#optionsBar input[type="radio" i], #optionsBar input[type="checkbox" i] {
		vertical-align: -0.09em;
	}
	#mapOptionsArea {
		display: flex;
		flex-wrap: wrap;
		align-items: center;
	}
	#optionsToggleArea {
		display: none;
		flex-wrap: wrap;
		align-items: center;
	}
	#weatherOptionsArea, #autoZoomOptions {
		display: inline-flex;
		flex-wrap: nowrap;
		align-items: center;
		margin: 0 5px;
	}
	#sevFilterOptions, #weatherOptions {
		display: flex;
		border: 1px solid #ddd;
		margin: 3px 10px 3px 5px;
		padding: 0;
		align-content: center;
		align-items: center;
		height: 30px;
		border-radius: 5px;
	}
	.sevFilterOption {
		display: inline-flex;
		align-items: center;
		padding: 0 3px;
	}
	#additionalOverlayOptions {
		padding: 0 5px;
		margin-left: 5px;
		border-left: 2px solid lightsteelblue;
		height: 25px;
		display: inline-flex;
		align-items: center;
	}
	#customGroupFilterOptions {
		padding-right: 10px;
		font-weight: bold;
	}
	#customGroupFilterField {
		background-color: #eee;
		border: 1px solid silver;
		font-family: Tahoma, Verdana, Roboto, monospace;
		max-width: 150px;
	}
	#refreshStatusArea {
		/* font-weight: bold; */
		font-size: medium;
		/* font-size: smaller; */
		/* color: white; */
		color: darkblue;
		display: inline-flex;
		flex-wrap: nowrap;
		align-items: center;
		text-wrap: nowrap;
	}
	:root {
		--warning-color: #f5ca1d;
		/* --warning-color: #f1c40f; */
		--error-color: #ff8c00;
		/* --error-color: #f57200; */
		--critical-color: #e0351b;
		--clear-color: #85c25d;
		/* --clear-color: #85c25d; */
		--sdt-color: #00a1fe;
	}
	#optionsBar .svg-inline--fa {
		font-size: initial;
	}
	#gearIcon:hover {
		filter: brightness(50%);
	}
	#clearCacheButton {
		height: 30px;
		width: auto;
		vertical-align: middle;
		background-color: white;
		border: 1px solid #ccc;
		border-radius: 3px;
		cursor: pointer;
	}
	#clearCacheButton:hover {
		background-color: #f0f0f0;
	}
	#recycleIcon {
		fill: gray;
	}
	.toolbarSevIcon {
		display: flex;
		max-width: 25px;
	}
	.disabled {
		opacity: 0.5 !important;
		cursor: not-allowed;
		pointer-events: none;
	}
	.noResultMessage {
		color: red;
		font-size: medium;
	}
	.sdtNote {
		font-size: 0.95em;
		font-style: italic;
		font-weight: 250;
	}
	.customItemArea {
		padding: 3px;
		margin-top: 3px;
		border-top: 1px solid #ddd;
		border-radius: 4px;
	}
	/* .customItem {
		padding-top: 3px;
	} */
	.customItem .customItemName {
		font-weight: bold;
	}
	.infoDialogIcon {
		height: 20px;
	}
	/*
	* group styles in unhighlighted state.
	*/
	.group {
		align-items: center;
		background-color: #FFFFFF;
		border-radius: 50%;
		color: #263238;
		display: flex;
		font-size: 14px;
		gap: 15px;
		height: 27px;
		/* height: 30px; */
		width: 27px;
		/* width: 30px; */
		justify-content: center;
		padding: 0px;
		position: relative;
		transition: all 0.3s ease-out;
	}
	.group::before {
		content: "";
		filter: blur(9px);
		display: block;
		border: 13px solid rgba(0, 0, 0, 0.7);
		border-radius: 50%;
		transform: scale(0.55, -0.4) translate(0px, -50px);
		/* transform: scale(0.55, -0.3) translate(0px, -70px); */
		position: absolute;
		z-index: -1;
	}
	.group::after {
		border-left: 9px solid transparent;
		border-right: 10px solid transparent;
		/* border-left: 11px solid transparent;
		border-right: 11px solid transparent; */
		border-top: 9px solid #FFFFFF;
		content: "";
		height: 0;
		left: 50%;
		position: absolute;
		top: 95%;
		transform: translate(-50%, 0);
		transition: all 0.3s ease-out;
		width: 0;
		/* filter: drop-shadow(0px 5px 3px rgba(0, 0, 0, 0.7)); */
	}
	.group .icon {
		align-items: center;
		display: flex;
		justify-content: center;
		color: #FFFFFF;
		/* padding-top: 5px; */
	}
	.group .icon svg {
		height: 20px;
		width: auto;
	}
	.group .details {
		display: none;
		flex-direction: column;
		flex: 1;
		min-width: 250px;
	}
	.group .groupName {
		font-weight: 600;
		margin-bottom: 8px;
		font-size: medium;
	}
	.group .groupName a {
		color: #1a73e8;
		text-decoration: none;
	}
	.group .groupName a:hover {
		text-decoration: underline;
	}
	.group .description {
		color: #5f6368;
		font-size: 12px;
		line-height: 1.4;
		margin-bottom: 12px;
	}
	.group .features {
		align-items: center;
		display: flex;
		flex-direction: row;
		gap: 8px;
		flex-wrap: wrap;
	}
	.group .features > div {
		align-items: center;
		background: #f8f9fa;
		border-radius: 4px;
		border: 1px solid #e8eaed;
		display: flex;
		font-size: 12px;
		gap: 6px;
		padding: 4px 8px;
		color: #3c4043;
		font-size: 13px;
	}
	.group .features > div.drillDownButton {
		background-color: #1a73e8;
		border-color: #1a73e8;
		cursor: pointer;
	}
	.group .features > div.drillDownButton a {
		color: white;
	}
	.group .features > div.drillDownButton:hover {
		background-color: #1557b0;
	}
	.group .close-button {
		display: none;
		position: absolute;
		top: 12px;
		right: 12px;
		background: transparent;
		border: none;
		cursor: pointer;
		padding: 4px;
		border-radius: 4px;
		color: #666;
		transition: all 0.2s ease;
	}
	.group .close-button:hover {
		background: #f1f1f1;
		color: #333;
	}
	.group .close-button svg {
		width: 16px;
		height: 16px;
	}
	/*
	* group styles in highlighted state.
	*/
	.group.highlight {
		background-color: #FFFFFF;
		/* border-radius: 8px;
		padding: 8px 15px;
		box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.5); */
		height: fit-content;
		/* height: 80px; */
		width: auto;
		z-index: 10;
		max-width: 400px;
	}
	.group.highlight::before {
		display: none;
	}
	/* .group.highlight::after {
		border-top: 9px solid #FFFFFF;
		top: 99%;
		filter: drop-shadow(0px 1px 1px rgba(0, 0, 0, 0.4));
	} */
	.group.highlight .details {
		display: flex;
		z-index: 10;
	}
	.group.highlight .icon svg {
		width: 50px;
		height: 50px;
	}
	.group .link {
		color: white;
	}
	.group .link:hover {
		/* color: -webkit-link; */
		color: lightcyan;
	}
	.group.highlight .close-button {
		display: block;
	}
	.indexText {
		z-index: 100;
	}
	/*
	* Cleared icon colors.
	*/
	.group.highlight:has(.clear) .icon {
		color: var(--clear-color);
	}
	.group:not(.highlight):has(.clear) {
		background-color: var(--clear-color);
	}
	.group:not(.highlight):has(.clear)::after {
		border-top: 9px solid var(--clear-color);
		top: 85%;
	}
	/*
	* Warning icon colors.
	*/
	.group.highlight:has(.warn) .icon {
		color: var(--warning-color);
	}
	.group:not(.highlight):has(.warn) {
		background-color: var(--warning-color);
	}
	.group:not(.highlight):has(.warn)::after {
		border-top: 9px solid var(--warning-color);
		top: 85%;
	}
	/*
	* Error icon colors.
	*/
	.group.highlight:has(.error) .icon {
		color: var(--error-color);
	}
	.group:not(.highlight):has(.error) {
		background-color: var(--error-color);
	}
	.group:not(.highlight):has(.error)::after {
		border-top: 9px solid var(--error-color);
		top: 85%;
	}
	/*
	* Critical icon colors.
	*/
	.group.highlight:has(.critical) .icon {
		color: var(--critical-color);
	}
	.group:not(.highlight):has(.critical) {
		background-color: var(--critical-color);
	}
	.group:not(.highlight):has(.critical)::after {
		border-top: 9px solid var(--critical-color);
		top: 85%;
	}
	/*
	* SDT icon colors.
	*/
	.group.highlight:has(.sdt) .icon {
		color: var(--sdt-color);
	}
	.group:not(.highlight):has(.sdt) {
		background-color: var(--sdt-color);
	}
	.group:not(.highlight):has(.sdt)::after {
		border-top: 9px solid var(--sdt-color);
		top: 85%;
	}

	/* Leaflet-specific styles */
	.leaflet-popup-content a:focus {
		outline: none;
	}
	.leaflet-popup-content {
		margin: 8px 12px;
	}
	.leaflet-popup-content-wrapper {
		border-radius: 8px;
	}
	
	/* Custom control button styles */
	.leaflet-control-custom {
		background-color: #fff;
		border: none;
		border-radius: 4px;
		box-shadow: 0 1px 5px rgba(0,0,0,0.4);
		cursor: pointer;
		width: 34px;
		height: 34px;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	.leaflet-control-custom:hover {
		background-color: #f4f4f4;
	}
	.leaflet-control-custom svg {
		width: 20px;
		height: 20px;
	}

	/* Marker cluster donut chart styles */
	.cluster-donut {
		background: transparent !important;
		border: none !important;
	}
	.cluster-donut svg {
		filter: drop-shadow(0px 2px 3px rgba(0,0,0,0.4));
	}

	/* Custom marker icon styles */
	.leaflet-marker-icon.group-marker {
		background: transparent !important;
		border: none !important;
	}

	[data-title]:hover:after {
		opacity: 1;
		transition: all 0.1s ease 0.5s;
		visibility: visible;
	}
	[data-title]:after {
		font-weight: normal;
		content: attr(data-title);
		position: absolute;
		top: 2em;
		left: 50%;
		margin-left: -75px;
		padding: 4px;
		color: white;
		border-radius: 5px;
		opacity: 0;
		visibility: hidden;
		z-index: 999;
		background-color: black;
		width: 150px;
	}
	[data-title] {
		position: relative;
	}
	.quakeMarker {
		filter: drop-shadow(0px 0px 3px white);
		position: absolute;
		top: 5px;
		width: 12px;
		height: 12px;
		background: #333;
		border-radius: 50%;
		display: flex;
		align-items: center;
		justify-content: center;
		border: 1px solid white;
	}

	/* Custom popup styles for overlays */
	.custom-overlay-popup .leaflet-popup-content-wrapper {
		padding: 0;
	}
	.custom-overlay-popup .leaflet-popup-content {
		margin: 12px;
		min-width: 200px;
	}

	/* Update status area styles for Leaflet */
	.leaflet-top .leaflet-control.update-status {
		background: white;
		padding: 8px 12px;
		border-radius: 4px;
		box-shadow: 0 1px 5px rgba(0,0,0,0.4);
		font-size: 14px;
		color: darkblue;
	}
</style>

<!-- Our main widget body... -->
<div class="customMapBody">
	<!-- Create our options bar above the map... -->
	<div id="optionsBar" class="optionsVisible">
		<div id="mapOptionsArea">
			<span id="customGroupFilterOptions" data-title="Path to the items you'd like on the map. Examples:&quot;*&quot;, &quot;Locations/*&quot;">
				<label for="customGroupFilterField">Group filter:</label>
				<input type="text" id="customGroupFilterField" name="customGroupFilterField" value="*" onkeypress="groupkeyHandler(event);" />
			</span>

			<span id="sevFilterOptions">
				<span class="sevFilterOption">
					<input type="checkbox" id="showCleared" name="showCleared" value="showCleared" onclick="refreshGroupData();" data-title="Show/hide items with no active alerts" />
					<label for="showCleared"><div id="showClearedLabel" class="toolbarSevIcon">Cleared</div></label>
				</span>
				<span class="sevFilterOption">
					<input type="checkbox" id="showWarnings" name="showWarnings" value="showWarnings" onclick="refreshGroupData();" data-title="Show/hide items with active Warning alerts" />
					<label for="showWarnings"><div id="showWarningsLabel" class="toolbarSevIcon">Warnings</div></label>
				</span>
				<span class="sevFilterOption">
					<input type="checkbox" id="showErrors" name="showErrors" value="showErrors" onclick="refreshGroupData();" data-title="Show/hide items with active Error alerts" />
					<label for="showErrors"><div id="showErrorsLabel" class="toolbarSevIcon">Errors</div></label>
				</span>
				<span class="sevFilterOption">
					<input type="checkbox" id="showCriticals" name="showCriticals" value="showCriticals" onclick="refreshGroupData();" data-title="Show/hide items with active Critical alerts" />
					<label for="showCriticals"><div id="showCriticalsLabel" class="toolbarSevIcon">Criticals</div></label>
				</span>
				<span class="sevFilterOption">
					<input type="checkbox" id="showSDT" name="showSDT" value="showSDT" onclick="refreshGroupData();" data-title="Show/hide items in Scheduled Down Time (SDT)" />
					<label for="showSDT"><div id="showSDTLabel" class="toolbarSevIcon">SDT</div></label>
				</span>
			</span>

			<span data-title="Toggle visibility of additional options">
				<svg id="optionsToggleButton" onclick="toggleMiscOptions()" width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="vertical-align: middle;"><path id="gearIcon" d="M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z" fill="#aaa"/></svg>
			</span>
			<svg id="gearIconChevron" style="display: none; margin-left: -3px;" width="10" height="15" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><path d="M246.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-9.2-9.2-22.9-11.9-34.9-6.9s-19.8 16.6-19.8 29.6l0 256c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l128-128z" fill="#999"/></svg>

			<div id="optionsToggleArea">
				<span id="autoZoomOptions" data-title="Automatically reset the map's zoom to encompass all items after timed refreshes. You can also manually do so at any time using the 'Reset map zoom' button on the left of the map.">
					<input type="checkbox" id="autoZoom" name="autoZoom" value="autoZoom" onclick="enableWeather();" checked="true" />
					<label for="autoZoom">Auto-zoom</label>
				</span>

				<span id="weatherOptionsArea">
					<span data-title="Enables overlay of current weather radar and more">
						<input type="checkbox" id="weather" name="weather" value="weather" onclick="enableWeather();" />
						<label for="weather">Weather</label>
					</span>

					<span id="weatherOptions">
						<span data-title="Weather across the globe (~10-15 minute updates)" onclick="enableWeather();">
							<input type="radio" id="globalWeather" name="weatherType" value="radar" checked="true" />
							<label for="globalWeather">Global</label>
						</span>

						<span data-title="US NEXRAD Base radar (~5 minute updates)" onclick="enableWeather();">
							<input type="radio" id="nexradWeather" name="weatherType" value="nexrad-n0q-900913" />
							<label for="nexradWeather">NEXRAD (US)</label>
						</span>

						<span id="additionalOverlayOptions">
							<!-- <strong class="optionsHeader">additional overlays:</strong> -->
							<span data-title="Active wildfires in the US and Australia" onclick="enableWeather();">
								<input type="radio" id="usWildfires" name="otherWeatherOverlays" value="us-fires" checked="true" />
								<label for="usWildfires">Wildfires</label>
							</span>

							<span data-title="US power outages by county" onclick="enableWeather();">
								<input type="radio" id="usPowerOutages" name="otherWeatherOverlays" value="us-poweroutages" />
								<label for="usPowerOutages">US Power Outages</label>
							</span>

							<span data-title="Significant earthquakes (magnitude 6+) over the past 7 days" onclick="enableWeather();">
								<input type="radio" id="earthquakes" name="otherWeatherOverlays" value="earthquakes" />
								<label for="earthquakes">Earthquakes</label>
							</span>

							<span data-title="Active US flood warnings" onclick="enableWeather();">
								<input type="radio" id="usFlooding" name="otherWeatherOverlays" value="us-flooding" />
								<label for="usFlooding">US Flooding</label>
							</span>

							<span data-title="Active tropical storms and hurricanes (NOAA NHC)" onclick="enableWeather();">
								<input type="radio" id="hurricanes" name="otherWeatherOverlays" value="hurricanes" />
								<label for="hurricanes">Hurricanes</label>
							</span>

							<span data-title="Air Quality Index contours (EPA AirNow)" onclick="enableWeather();">
								<input type="radio" id="airQuality" name="otherWeatherOverlays" value="air-quality" />
								<label for="airQuality">Air Quality</label>
							</span>
						</span>
					</span>
				</span>
				<button id="clearCacheButton" type="button" data-title="Reset addresses cached locally on your browser (should rarely be needed, only use if you're having issues with the map)" onclick="clearCache();">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" height="20" width="20" style="vertical-align: middle;"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path id="recycleIcon" d="M216.3 124C262.5 44 378 44 424.2 124L461.5 188.6L489.2 172.6C497.6 167.7 508.1 168.4 515.8 174.3C523.5 180.2 526.9 190.2 524.4 199.6L500.9 287C497.5 299.8 484.3 307.4 471.5 304L384.1 280.6C374.7 278.1 367.8 270.2 366.5 260.6C365.2 251 369.9 241.5 378.3 236.7L406 220.7L368.7 156.1C347.1 118.8 293.3 118.8 271.7 156.1L266.4 165.2C257.6 180.5 238 185.7 222.7 176.9C207.4 168.1 202.2 148.5 211 133.1L216.3 124zM513.7 343.1C529 334.3 548.6 339.5 557.4 354.8L562.7 363.9C608.9 443.9 551.2 543.9 458.8 543.9L384.2 543.9L384.2 575.9C384.2 585.6 378.4 594.4 369.4 598.1C360.4 601.8 350.1 599.8 343.2 592.9L279.2 528.9C269.8 519.5 269.8 504.3 279.2 495L343.2 431C350.1 424.1 360.4 422.1 369.4 425.8C378.4 429.5 384.2 438.3 384.2 448L384.2 480L458.8 480C501.9 480 528.9 433.3 507.3 396L502 386.9C493.2 371.6 498.4 352 513.7 343.2zM115 299.4L87.3 283.4C78.9 278.5 74.2 269.1 75.5 259.5C76.8 249.9 83.7 242 93.1 239.5L180.5 216C193.3 212.6 206.5 220.2 209.9 233L233.3 320.4C235.8 329.8 232.4 339.7 224.7 345.7C217 351.7 206.5 352.3 198.1 347.4L170.4 331.4L133.1 396C111.5 433.3 138.5 480 181.6 480L192.2 480C209.9 480 224.2 494.3 224.2 512C224.2 529.7 209.9 544 192.2 544L181.6 544C89.3 544 31.6 444 77.8 364L115 299.4z"/></svg>
				</button>
			</div>
		</div>

		<!-- <span id="refreshStatusArea">&nbsp;</span> -->
	</div>

	<!-- Placeholder for our map... -->
	<div id="leafletMap"></div>
</div>

<script>
	// ------------------------------------------------------------
	// CSRF Token caching for performance optimization
	let _cachedCsrfToken = null;
	let _csrfTokenExpiry = 0;
	const CSRF_TOKEN_TTL = 5 * 60 * 1000; // Cache token for 5 minutes

	// AbortController for canceling in-progress refresh operations
	let _currentRefreshController = null;

	// Utility: Debounce function for rate-limiting user input handlers
	function debounce(fn, delay = 300) {
		let timeoutId;
		return (...args) => {
			clearTimeout(timeoutId);
			timeoutId = setTimeout(() => fn(...args), delay);
		}
	}

	// Helper: Check if a token value represents a truthy boolean
	function isTruthyToken(tokenValue) {
		const lower = tokenValue.toLowerCase();
		return lower === "true" || lower === "yes" || lower === "1";
	}

	/**
	* Fetches a Cross-Site Request Forgery (CSRF) token required for subsequent API calls.
	* Implements caching to avoid redundant network requests within the TTL period.
	*
	* This function makes a preliminary request to a dummy endpoint solely to retrieve
	* the CSRF token from the response headers.
	*
	* Credit for this function goes to Steven Villardi
	*
	* @async
	* @function fetchCsrfToken
	* @param {boolean} [forceRefresh=false] - Force a fresh token fetch, bypassing the cache.
	* @returns {Promise<string>} A promise that resolves with the CSRF token.
	* @throws {Error} If the fetch request fails or the token is not found in headers.
	*/
	async function fetchCsrfToken(forceRefresh = false) {
		// Return cached token if still valid and not forcing refresh
		if (!forceRefresh && _cachedCsrfToken && Date.now() < _csrfTokenExpiry) {
			// console.debug('Using cached CSRF token...');
			return _cachedCsrfToken;
		}

		// console.debug('Fetching fresh CSRF token...');
		const response = await fetch('/santaba/rest/functions/dummy', {
			method: 'GET',
			headers: {
				'X-Csrf-Token': 'Fetch', // Specific header to request the token
				'Accept': 'application/json',
				'X-Version': '3', // Specify API version if required by this endpoint
			},
			credentials: 'include', // Include cookies for session management/CSRF
		});

		if (!response.ok) {
			// Clear cache on failure
			_cachedCsrfToken = null;
			_csrfTokenExpiry = 0;
			throw new Error(`Failed to fetch CSRF token: ${response.status} ${response.statusText}`);
		}

		const token = response.headers.get('X-Csrf-Token');
		if (!token) {
			throw new Error('CSRF token not found in response headers.');
		}

		// Cache the token
		_cachedCsrfToken = token;
		_csrfTokenExpiry = Date.now() + CSRF_TOKEN_TTL;
		// console.debug('CSRF Token fetched and cached successfully.');

		return token;
	}

	/**
		* Performs an HTTP request to the LogicMonitor REST API.
		*
		* This function handles fetching a CSRF token, constructing the API request,
		* sending the request, and processing the response. It supports common HTTP verbs
		* and automatically includes necessary headers and credentials.
		*
		* Credit for this function goes to Steven Villardi
		*
		* @async
		* @function LMClient
		* @param {object} options - The options for the API request.
		* @param {string} options.resourcePath - The specific API resource path (e.g., /device/devices).
		* @param {string} [options.queryParams=''] - Optional query parameters string (e.g., ?filter=name:value).
		* @param {'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'} options.httpVerb - The HTTP method to use.
		* @param {object | Array<unknown>} [options.postBody] - The JSON payload for POST/PUT/PATCH requests.
		* @param {string} [options.apiVersion='3'] - The API version to use. Default is "3".
		* @param {AbortSignal} [options.signal] - Optional AbortSignal for canceling the request.
		* @returns {Promise<object>} A promise that resolves with the JSON response body on success.
		* @throws {Error} Throws an Error on API errors (>=300 status), network issues,
		*                 token fetching problems, or JSON handling errors. The error object
		*                 may contain 'status' and 'statusText' properties for API errors.
	*/
	async function LMClient({
		resourcePath,
		queryParams = '', // Default queryParams to empty string
		httpVerb,
		postBody,
		apiVersion = '3',
		signal = null, // Optional AbortSignal for request cancellation
	}) {
		// console.debug('LMClient called with:', { resourcePath, queryParams, httpVerb, postBody, apiVersion });
		// Validate required parameters
		if (!resourcePath || !httpVerb) {
			throw new Error('Missing required parameters: resourcePath and httpVerb must be provided.');
		}
		const validVerbs = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];
		if (!validVerbs.includes(httpVerb)) {
			throw new Error(`Invalid httpVerb: ${httpVerb}. Must be one of ${validVerbs.join(', ')}`);
		}

		// console.debug(`Initiating LogicMonitor API call: ${httpVerb} ${resourcePath}${queryParams}`);

		try {
			// 1. Fetch the CSRF token
			const csrfToken = await fetchCsrfToken();

			// 2. Construct the API URL and request options
			const apiUrl = `/santaba/rest${resourcePath}${queryParams}`;
			const headers = {
				'Content-Type': 'application/json', // Consistently set Content-Type
				'Accept': 'application/json', // Expect JSON response
				'X-Csrf-Token': csrfToken,
				'X-Version': apiVersion, // Use the appropriate API version for the main request
			}

			const requestOptions = {
				method: httpVerb,
				headers: headers,
				credentials: 'include', // Necessary for session/cookie-based auth
			}

			// Add AbortSignal if provided
			if (signal) {
				requestOptions.signal = signal;
			}

			// 3. Add body only for relevant methods
			if (postBody && (httpVerb === 'POST' || httpVerb === 'PUT' || httpVerb === 'PATCH')) {
				try {
					requestOptions.body = JSON.stringify(postBody);
					// console.debug('Request body included:', postBody);
				} catch (stringifyError) {
					console.error('Failed to stringify postBody:', stringifyError);
					// Add user-friendly message to the error
					stringifyError.message = `Invalid postBody provided. Could not stringify to JSON. Original error: ${stringifyError.message}`;
					throw stringifyError;
				}
			}

			// 4. Make the API call
			// console.debug(`Executing fetch to: ${apiUrl}`);
			const response = await fetch(apiUrl, requestOptions);
			// console.debug(`Received response status: ${response.status} ${response.statusText}`);

			// 5. Process the response
			if (response.ok) { // ok is true for statuses 200-299
				// Handle potential empty response body for certain success statuses (e.g., 204 No Content)
				if (response.status === 204) {
					console.debug('Received 204 No Content response.');
					return {}; // Return an empty object for 204
				}
				try {
					// Assume response is JSON if status is ok and not 204
					const data = await response.json();
					// console.debug('API call successful, response data received.'); // Avoid logging potentially sensitive data by default
					return data;
				} catch (jsonError) {
					console.error('Failed to parse JSON response:', jsonError);
					// Create a new error with more context
					const parseError = new Error(`Successfully received response (${response.status}), but failed to parse JSON body. Original error: ${jsonError.message}`);
					parseError.status = response.status; // Attach status for context
					parseError.statusText = response.statusText;
					throw parseError;
				}
			} else {
				// Handle API errors (status >= 300)
				const error = new Error(`API Error: ${response.status} ${response.statusText}`);
				error.status = response.status;
				error.statusText = response.statusText;

				// Attempt to get more details from the error response body
				try {
					const errorBody = await response.text(); // Use text first in case it's not JSON
					error.body = errorBody || 'No additional error details provided.'; // Attach body to error
					console.warn(`API Error Body: ${error.body}`); // Log the raw error body
				} catch (bodyError) {
					console.warn('Could not read error response body:', bodyError);
					error.body = 'Could not read error response body.';
				}
				console.error('LogicMonitor API Error:', { status: error.status, statusText: error.statusText });
				throw error; // Throw the augmented error object
			}
		} catch (error) {
			// Catch errors from fetchCsrfToken, fetch itself (network errors), or JSON parsing/stringifying
			console.error('An error occurred in LMClient:', error.message || error);

			// Re-throw the error to be handled by the caller.
			// Ensure it's always an Error object.
			if (error instanceof Error) {
				throw error;
			} else {
				// If it's not an Error object (e.g., the thrown API error object), wrap it
				const wrappedError = new Error(error.message || 'An unexpected error occurred during the API call.');
				// Copy relevant properties if they exist
				if (error && typeof error === 'object') {
					if ('status' in error) wrappedError.status = error.status;
					if ('statusText' in error) wrappedError.statusText = error.statusText;
					if ('body' in error) wrappedError.body = error.body;
				}
				throw wrappedError;
			}
		}
	}

	// ------------------------------------------------------------
	// Capture information from specific dashboard tokens we'll be using...
	// (Like any token inserted into the Text widget, LogicMonitor automatically inserts these token values as the page is being rendered so Javascript is able to pick them as if the values were there originally. If a token isn't set then the variable's value will be literally what's shown below, including the double-hashtags.)

	// Capture from token whether to plot "groups" or "resources" or "services"...
	let mapSourceTypeToken = "##MapSourceType##";
	// If the token value wasn't set then use the values hard-coded above at the beginning of this script...
	if (mapSourceTypeToken != "\#\#MapSourceType\#\#") {
		mapSourceType = mapSourceTypeToken.toLowerCase();
	}

	// Capture from token whether override the map theme...
	let mapStyleToken = "##MapStyle##";
	// If the token value wasn't set then use the values hard-coded above at the beginning of this script...
	if (mapStyleToken != "\#\#MapStyle\#\#") {
		mapStyle = mapStyleToken.toLowerCase();
	}

	// Capture from token whether to hide the map options...
	let hideMapOptionsByDefaultToken = "##HideMapOptions##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(hideMapOptionsByDefaultToken)) {
		hideMapOptionsByDefault = true;
	}

	// Capture from token whether to hide items that don't have active alerts...
	let ignoreClearedToken = "##MapIgnoreCleared##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(ignoreClearedToken)) {
		showCleared = false;
	}
	// Capture from token whether to hide items that have "Warning" alerts...
	let ignoreWarningsToken = "##MapIgnoreWarnings##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(ignoreWarningsToken)) {
		showWarnings = false;
	}
	// Capture from token whether to hide items that have "Error" alerts...
	let ignoreErrorsToken = "##MapIgnoreErrors##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(ignoreErrorsToken)) {
		showErrors = false;
	}
	// Capture from token whether to hide items that have "Critical" alerts...
	let ignoreCriticalsToken = "##MapIgnoreCriticals##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(ignoreCriticalsToken)) {
		showCriticals = false;
	}
	// Capture from token whether to hide items that are in SDT...
	let ignoreSDTToken = "##MapIgnoreSDT##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(ignoreSDTToken)) {
		showSDT = false;
	}
	// Capture from token whether to show the map tilt/rotation controls...
	let showMapTiltControlsToken = "##MapShowTiltControls##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(showMapTiltControlsToken)) {
		showMapTiltControls = true;
	}

	// Capture from token whether to automatically reset the map's zoom to encompass all items on timed refreshes...
	let autoResetMapOnRefreshToken = "##AutoResetMapOnRefresh##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(autoResetMapOnRefreshToken)) {
		autoResetMapOnRefresh = true;
	}

	// Capture our group filter if defined as a token...
	let dashboardGroupPathToken = "##MapGroupPathFilter##";
	if (dashboardGroupPathToken != "\#\#MapGroupPathFilter\#\#") {
		groupPathFilter = dashboardGroupPathToken;
	}
	if (groupPathFilter == "") {
		// Default to "*" if no value was given...
		groupPathFilter = "*";
	}
	// Capture the current path filter to reset the form field if the user completely clears it out...
	const initialGroupPathFilter = groupPathFilter;

	// Capture our overlay defaults if defined as tokens...
	let dashboardShowWeatherToken = "##MapShowWeather##".toLowerCase();
	if (dashboardShowWeatherToken == "global" || dashboardShowWeatherToken == "nexrad") {
		showWeatherDefault = dashboardShowWeatherToken;
	}
	let dashboardAddlOverlayToken = "##MapOverlayOption##".toLowerCase();
	if (dashboardAddlOverlayToken == "wildfires" || dashboardAddlOverlayToken == "us-wildfires" || dashboardAddlOverlayToken == "outages" || dashboardAddlOverlayToken == "us-poweroutages" || dashboardAddlOverlayToken == "earthquakes" || dashboardAddlOverlayToken == "us-flooding" || dashboardAddlOverlayToken == "hurricanes" || dashboardAddlOverlayToken == "air-quality") {
		additionalOverlayOption = dashboardAddlOverlayToken;
	}

	// Capture from token any custom properties to display when viewing an item's details...
	let displayPropsToken = "##MapDisplayProperties##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (displayPropsToken != "\#\#MapDisplayProperties\#\#") {
		displayProps = displayPropsToken;
	}

	// Capture from token whether to disable marker clustering...
	let disableClusteringToken = "##MapDisableClustering##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(disableClusteringToken)) {
		disableClustering = true;
	}

	// Whether to show road labels on the map...
	let showRoadLabelsToken = "##MapShowRoadLabels##";
	// If the token value wasn't set then use the value hard-coded above at the beginning of this script...
	if (isTruthyToken(showRoadLabelsToken)) {
		showRoadLabels = "yes";
	}

	// Cache frequently accessed DOM elements for performance
	const _dom = {
		showCleared: document.getElementById("showCleared"),
		showWarnings: document.getElementById("showWarnings"),
		showErrors: document.getElementById("showErrors"),
		showCriticals: document.getElementById("showCriticals"),
		showSDT: document.getElementById("showSDT"),
		autoZoom: document.getElementById("autoZoom"),
		weather: document.getElementById("weather"),
		globalWeather: document.getElementById("globalWeather"),
		nexradWeather: document.getElementById("nexradWeather"),
		usWildfires: document.getElementById("usWildfires"),
		usPowerOutages: document.getElementById("usPowerOutages"),
		earthquakes: document.getElementById("earthquakes"),
		usFlooding: document.getElementById("usFlooding"),
		customGroupFilterField: document.getElementById("customGroupFilterField"),
		mapOptionsArea: document.getElementById("mapOptionsArea"),
		refreshStatusArea: null, // Set later after map init
		weatherRefreshButton: null, // Set later after map init
		showClearedLabel: document.getElementById("showClearedLabel"),
		showWarningsLabel: document.getElementById("showWarningsLabel"),
		showErrorsLabel: document.getElementById("showErrorsLabel"),
		showCriticalsLabel: document.getElementById("showCriticalsLabel"),
		showSDTLabel: document.getElementById("showSDTLabel"),
	}

	// Set the form fields as appropriate...
	_dom.showCleared.checked = showCleared;
	_dom.showWarnings.checked = showWarnings;
	_dom.showErrors.checked = showErrors;
	_dom.showCriticals.checked = showCriticals;
	_dom.showSDT.checked = showSDT;
	_dom.autoZoom.checked = autoResetMapOnRefresh;

	if (showWeatherDefault == "global") {
		_dom.weather.checked = true;
		_dom.globalWeather.checked = true;
	} else if (showWeatherDefault == "nexrad") {
		_dom.weather.checked = true;
		_dom.nexradWeather.checked = true;
	}

	if (additionalOverlayOption == "wildfires" || additionalOverlayOption == "us-wildfires") {
		_dom.usWildfires.checked = true;
	} else if (additionalOverlayOption == "outages" || additionalOverlayOption == "us-poweroutages") {
		_dom.usPowerOutages.checked = true;
	} else if (additionalOverlayOption == "earthquakes") {
		_dom.earthquakes.checked = true;
	} else if (additionalOverlayOption == "us-flooding") {
		_dom.usFlooding.checked = true;
	}

	// Capture information about the current dashboard for use in subsequent REST calls...
	const hostName = parent.window.location.host;
	const locationHash = parent.window.location.hash; // example result: "#dashboard=21"
	const dashboardID = locationHash.replace("#dashboard=", "");
	const pathName = parent.window.location.pathname;

	// Note: Leaflet doesn't support tilt/heading like Google Maps
	// These variables are kept for compatibility but not used
	const defaultMapTilt = 0;
	const defaultMapHeading = 0;

	// SVG icon definitions for our different alert severities...
	const warningIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 1024 1024" data-tooltip="Warning"><path fill="#f5ca1d" d="M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z"></path> <path fill="white" d="M866.462 669.538l-275.692-433.231c-43.323-70.892-114.215-70.892-157.538 0l-275.692 433.231c-43.323 70.892-3.938 157.538 78.769 157.538h551.385c82.708 0 122.092-86.646 78.769-157.538v0 0z"></path> <path fill="#f5ca1d" d="M551.385 748.308h-78.769v-78.769h78.769v78.769zM551.385 630.154h-78.769v-275.692h78.769v275.692z"></path> </svg>';
	const errorIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 1024 1024" data-tooltip="Error"><path fill="#ff8c00" d="M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z"></path> <path fill="white" d="M866.462 669.538l-275.692-433.231c-43.323-70.892-114.215-70.892-157.538 0l-275.692 433.231c-43.323 70.892-3.938 157.538 78.769 157.538h551.385c82.708 0 122.092-86.646 78.769-157.538v0 0z"></path> <path fill="#ff8c00" d="M551.385 748.308h-78.769v-78.769h78.769v78.769zM551.385 630.154h-78.769v-275.692h78.769v275.692z"></path> </svg>';
	const criticalIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 1024 1024" data-tooltip="Critical"><path fill="#e0351b" d="M118.154 118.154h787.692c43.323 0 78.769 35.446 78.769 78.769v630.154c0 43.323-35.446 78.769-78.769 78.769h-787.692c-43.323 0-78.769-35.446-78.769-78.769v-630.154c0-43.323 35.446-78.769 78.769-78.769v0 0z"></path> <path fill="white" d="M827.077 590.769c-133.908-232.369-39.385-354.462-39.385-354.462s-173.292 43.323-157.538 157.538c-35.446-31.508-216.615-86.646-114.215-271.754v-3.938h-3.938c-3.938 0-55.138 23.631-94.523 74.831-39.385 47.262-110.277 106.338-63.015 240.246 31.508 74.831 39.385 94.523-39.385 157.538 3.938-15.754 11.815-51.2 0-78.769-27.569-63.015-78.769-78.769-78.769-78.769s43.323 66.954 0 118.154c-39.385 43.323-55.138 129.969-35.446 200.862 15.754 59.077 70.892 106.338 157.538 137.846-7.877-3.938 110.277 43.323 244.185 3.938 59.077-19.692 137.846-43.323 185.108-106.338 39.385-51.2 74.831-129.969 39.385-196.923v0 0z"></path> <path fill="#e0351b" d="M551.385 827.077h-78.769v-78.769h78.769v78.769zM551.385 708.923h-78.769v-275.692h78.769v275.692z"></path> </svg>';
	const clearedIcon = '<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg" data-tooltip="No alerts"><path id="Shape" fill="#ffffff" fill-rule="evenodd" stroke="none" d="M 43 25 C 43 15.61116 35.164986 8 25.5 8 C 15.835016 8 8 15.61116 8 25 C 8 34.38884 15.835016 42 25.5 42 C 35.164986 42 43 34.38884 43 25 Z"/><path id="Path" fill="#85c25d" stroke="none" d="M 25.5 4 C 37.374119 4 47 13.625877 47 25.5 C 47 37.374123 37.374119 47 25.5 47 C 13.625877 47 4 37.374123 4 25.5 C 4 13.625877 13.625877 4 25.5 4 Z M 17.975 17.974998 C 15.881312 17.974998 14.103745 18.670809 12.642242 20.062449 C 11.18074 21.45409 10.45 23.269981 10.45 25.510181 C 10.45 27.736805 11.18074 29.545912 12.642242 30.937551 C 14.103745 32.329193 15.881312 33.025002 17.975 33.025002 C 20.068687 33.025002 21.842855 32.329193 23.297562 30.937551 C 24.752264 29.545912 25.479607 27.736805 25.479607 25.510181 C 25.479607 23.283558 24.752264 21.471062 23.297562 20.072632 C 21.842855 18.674204 20.068687 17.974998 17.975 17.974998 Z M 31.006098 18.280481 L 27.784012 18.280481 L 27.784012 32.719521 L 31.006098 32.719521 L 31.006098 28.850101 L 32.637535 27.037582 L 36.532589 32.719521 L 40.549999 32.719521 L 34.901154 24.532646 L 40.529606 18.280481 L 36.287876 18.280481 L 31.006098 24.34936 L 31.006098 18.280481 Z M 17.975 21.111265 C 19.089819 21.111265 20.061874 21.48802 20.891193 22.241541 C 21.72051 22.995064 22.135162 24.07781 22.135162 25.489815 C 22.135162 26.901821 21.72051 27.981174 20.891193 28.727909 C 20.061874 29.474642 19.089819 29.848003 17.975 29.848003 C 16.86018 29.848003 15.884727 29.474642 15.048611 28.727909 C 14.212496 27.981174 13.794444 26.901821 13.794444 25.489815 C 13.794444 24.07781 14.209096 22.998459 15.038414 22.251724 C 15.881327 21.491413 16.86018 21.111265 17.975 21.111265 Z"/></svg>';
	const sdtIcon = '<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg" data-tooltip="SDT"><path id="Oval" fill="#00A1FE" fill-rule="evenodd" stroke="none" d="M 46 25 C 46 13.40202 36.59798 4 25 4 C 13.40202 4 4 13.40202 4 25 C 4 36.59798 13.40202 46 25 46 C 36.59798 46 46 36.59798 46 25 Z"/><g id="Group"><path id="Path" fill="#000000" fill-opacity="0.01" stroke="none" d="M 5 5 L 45 5 L 45 45 L 5 45 Z"/><path id="path1" fill="#ffffff" stroke="none" d="M 25 9.0625 C 16.19795 9.0625 9.0625 16.197948 9.0625 25 C 9.0625 33.801994 16.19795 40.9375 25 40.9375 C 33.801998 40.9375 40.9375 33.801994 40.9375 25 L 36.25 25 C 36.25 31.213245 31.213249 36.25 25 36.25 C 18.7868 36.25 13.75 31.213245 13.75 25 C 13.75 18.786802 18.7868 13.75 25 13.75 L 25 9.0625 Z"/><path id="path2" fill="#ffffff" stroke="none" d="M 33.75 12.5 C 33.75 13.880699 32.630753 15 31.25 15 C 29.869299 15 28.75 13.880699 28.75 12.5 C 28.75 11.119301 29.869299 10 31.25 10 C 32.630753 10 33.75 11.119301 33.75 12.5 Z"/><path id="path3" fill="#ffffff" stroke="none" d="M 40 18.75 C 40 20.130701 38.880753 21.25 37.5 21.25 C 36.119247 21.25 35 20.130701 35 18.75 C 35 17.369301 36.119247 16.25 37.5 16.25 C 38.880753 16.25 40 17.369301 40 18.75 Z"/><path id="path4" fill="#ffffff" fill-rule="evenodd" stroke="none" d="M 23.125 16.000004 L 26.880026 16.000004 L 26.880026 24.899998 L 33.125 28.647003 L 30.725 31.83075 L 23.125 27.066555 L 23.125 16.000004 Z"/></g></svg>';
	// Animated throbber for when we're updating data...
	const loadingSpinner = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><style>.spinner_VpEe{animation:spinner_vXu6 1.2s cubic-bezier(0.52,.6,.25,.99) infinite}.spinner_eahp{animation-delay:.4s}.spinner_f7Y2{animation-delay:.8s}@keyframes spinner_vXu6{0%{r:0;opacity:1}100%{r:11px;opacity:0}}</style><circle class="spinner_VpEe" cx="12" cy="12" r="0" fill="red"/><circle class="spinner_VpEe spinner_eahp" cx="12" cy="12" r="0" fill="red"/><circle class="spinner_VpEe spinner_f7Y2" cx="12" cy="12" r="0" fill="red"/></svg>';
	// Icons for toggling visiiblity of the top toolbar...
	const optionsToggleVisibleIcon = '<svg class="svg-inline--fa fa-square-caret-up" aria-hidden="true" focusable="false" data-prefix="far" data-icon="square-caret-up" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg="" style="width: 25px; height: 25px;"><path fill="#000000" d="M241.6 175.7C237.1 170.8 230.7 168 224 168S210.9 170.8 206.4 175.7l-96 104c-6.469 7-8.188 17.19-4.375 25.91C109.8 314.3 118.5 320 127.1 320h192c9.531 0 18.16-5.656 22-14.38c3.813-8.719 2.094-18.91-4.375-25.91L241.6 175.7zM384 32H64C28.65 32 0 60.66 0 96v320c0 35.34 28.65 64 64 64h320c35.35 0 64-28.66 64-64V96C448 60.66 419.3 32 384 32zM400 416c0 8.82-7.178 16-16 16H64c-8.822 0-16-7.18-16-16V96c0-8.82 7.178-16 16-16h320c8.822 0 16 7.18 16 16V416z"></path></svg>';
	const optionsToggleHiddenIcon = '<svg class="svg-inline--fa fa-square-caret-down" aria-hidden="true" focusable="false" data-prefix="far" data-icon="square-caret-down" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg="" style="width: 25px; height: 25px;"><path fill="#000000" d="M320 192H128C118.5 192 109.8 197.7 105.1 206.4C102.2 215.1 103.9 225.3 110.4 232.3l96 104C210.9 341.2 217.3 344 224 344s13.09-2.812 17.62-7.719l96-104c6.469-7 8.188-17.19 4.375-25.91C338.2 197.7 329.5 192 320 192zM384 32H64C28.65 32 0 60.66 0 96v320c0 35.34 28.65 64 64 64h320c35.35 0 64-28.66 64-64V96C448 60.66 419.3 32 384 32zM400 416c0 8.82-7.178 16-16 16H64c-8.822 0-16-7.18-16-16V96c0-8.82 7.178-16 16-16h320c8.822 0 16 7.18 16 16V416z"></path></svg>';


	// Leaflet tile provider URLs for different map styles
	// These replace the Google Maps styled map types with equivalent Leaflet tile providers
	const tileProviders = {
		standard: {
			url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
			maxZoom: 20
		},
		silver: {
			url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
			maxZoom: 20
		},
		silverblue: {
			url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
			maxZoom: 20
		},
		dark: {
			url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
			maxZoom: 20
		},
		aubergine: {
			url: 'https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png',
			attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
			maxZoom: 20
		}
	};

	// RainViewer map options (feel free to change these to suit your taste)...
	const rvOptionKind = 'radar'; // can be 'radar' or 'satellite'
	const rvOptionColorScheme = 4; // from 0 to 8. Check the https://rainviewer.com/api/color-schemes.html for additional inforvation
	const rvOptionSmoothData = 1; // 0 - not smooth, 1 - smooth
	const rvOptionSnowColors = 1; // 0 - do not show snow colors, 1 - show snow colors
	// Variables for holding RainViewer API data...
	let rvAPIData = {};
	let rvMapFrames = [];
	let rvLastPastFramePosition = -1;
	let weatherRefresher = null;

	// Number formatter for use in wildfire data...
	const numFormatOptions = {
		style: 'decimal',  // Other options: 'currency', 'percent', etc.
		minimumFractionDigits: 0,
		maximumFractionDigits: 0,
	}

	// Adding a top-level placeholder for our Leaflet map objects...
	let map = null;
	let clusterer = null;
	let bounds = null;
	let baseTileLayer = null;
	let weatherTileLayer = null;
	let overlayLayer = null;
	let hurricaneLayer = null;
	let aqiLayer = null;

	// Fetch helper with timeout & AbortController...
	if (!window.fetchJson) {
		window.fetchJson = async function(url, { timeoutMs = 8000 } = {}) {
			const ac = new AbortController();
			const timer = setTimeout(() => ac.abort("timeout"), timeoutMs);
			try {
				const res = await fetch(url, { signal: ac.signal, credentials: "omit", cache: "no-store" });
				if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
				const ct = res.headers.get("content-type") || "";
				if (ct.includes("application/json")) return await res.json();
				return await res.text();
			} finally { clearTimeout(timer); }
		}
	}

	// Batch builder to avoid jank when (re)building many markers...
	if (!window.buildMarkersInBatches) {
		window.buildMarkersInBatches = async function(items, fn, batchSize = 250) {
			for (let i = 0; i < items.length; i += batchSize) {
				const slice = items.slice(i, i + batchSize);
				for (const it of slice) { try { fn(it); } catch(e) {} }
				await new Promise(r => { if ('requestIdleCallback' in window) requestIdleCallback(()=>r()); else setTimeout(r,0); });
			}
		}
	}

	// Variable for holding our map markers...
	let markers = [];
	// Map for O(1) marker lookups by device ID (performance optimization)
	let markersByDeviceID = new Map();
	// For tracking if we've already established an initial center for our map based on markers...
	let centerCalculated = false;
	// For storing polyline references and their marker associations...
	let polylines = [];

	// Utility function to clear all markers from the map (consolidates repeated code)
	function clearAllMarkers() {
		if (clusterer) {
			clusterer.clearLayers();
		}
		markers.forEach(m => {
			if (map && map.hasLayer(m)) {
				map.removeLayer(m);
			}
		});
		markers = [];
		markersByDeviceID.clear();
	}

	// Clear all connecting polylines and their listeners
	function clearAllPolylines() {
		if (polylines.length === 0) return;
		// console.debug("Clearing " + polylines.length + " polylines");
		polylines.forEach(p => {
			if (p && p.polyline && map) {
				map.removeLayer(p.polyline);
			}
		});
		polylines = [];
	}

	// Update polyline endpoints to follow clusters/markers
	function updatePolylineEndpoints() {
		if (!polylines.length) return;
		// console.debug("Updating " + polylines.length + " polyline endpoints");
		polylines.forEach(p => {
			if (!p || !p.polyline) return;
			const sourcePos = getMarkerOrClusterPosition(p.sourceDeviceID);
			const targetPos = getMarkerOrClusterPosition(p.targetDeviceID);
			if (sourcePos && targetPos) {
				p.polyline.setLatLngs([sourcePos, targetPos]);
			}
		});
	}

	// Resolve a device's current visible position (cluster center or marker)
	function getMarkerOrClusterPosition(deviceID) {
		if (!deviceID) return null;
		// Use Map for O(1) lookup instead of array find
		const marker = markersByDeviceID.get(deviceID) || markersByDeviceID.get(String(deviceID));
		if (!marker) return null;

		// Check if marker is visible on map (not in a cluster)
		if (clusterer && !map.hasLayer(marker)) {
			// Marker is clustered - find the cluster it belongs to
			const visibleParent = clusterer.getVisibleParent(marker);
			if (visibleParent && visibleParent !== marker) {
				return visibleParent.getLatLng();
			}
		}

		// Marker is not clustered - return its position
		return marker.getLatLng();
	}

	// For caching marker latitude/longitude information between refreshes...
	const __LMBMW_CACHE_KEY = "lm_bmw.cachedAddresses.v1";
	function loadCache() {
		try {
			const obj = JSON.parse(localStorage.getItem(__LMBMW_CACHE_KEY));
			return (obj && typeof obj === "object") ? obj : {};
		} catch (e) { return {}; }
	}
	function saveCache() {
		try { localStorage.setItem(__LMBMW_CACHE_KEY, JSON.stringify(cachedAddresses)); } catch (e) {}
	}
	// Debounced version to avoid excessive localStorage writes during batch operations
	const debouncedSaveCache = debounce(saveCache, 1000);
	function clearCache() {
		try {
			localStorage.removeItem(__LMBMW_CACHE_KEY);
			// Display our progress to the user (if status area is available)...
			if (!_dom.refreshStatusArea) {
				_dom.refreshStatusArea = document.getElementById("refreshStatusArea");
			}
			if (_dom.refreshStatusArea) {
				_dom.refreshStatusArea.innerHTML = "Cache has been reset";
				_dom.refreshStatusArea.style.display = "flex";
				// Add timer to remove message after 2 seconds...
				setTimeout(() => {
					_dom.refreshStatusArea.innerHTML = "";
					_dom.refreshStatusArea.style.display = "none";
				}, 2000);
			}
		} catch (e) {}
	}
	let cachedAddresses = loadCache();

	// For holding our LM group data...
	let groupData = [];
	// For timing our refreshes...
	let refreshStartTime = new Date();
	// For tracking when to do a full refresh...
	let pollCount = 0;
	let fullRefresh = true;

	// For holding our connection status data...
	let lineData = [];

	// Pre-populate the group path filter field...
	_dom.customGroupFilterField.value = groupPathFilter;

	// Set toolbar icons...
	_dom.showClearedLabel.innerHTML = clearedIcon;
	_dom.showWarningsLabel.innerHTML = warningIcon;
	_dom.showErrorsLabel.innerHTML = errorIcon;
	_dom.showCriticalsLabel.innerHTML = criticalIcon;
	_dom.showSDTLabel.innerHTML = sdtIcon;

	// Placeholder for marker cluster info...
	let clusterInfoWindow = null;
	let markerInfoWindow = null;

	// Track map initialization state...
	let mapInitialized = false;
	let initInProgress = false;
	let initAttempts = 0;
	const MAX_INIT_ATTEMPTS = 10;

	// Robust map initialization wrapper that handles timing issues in dashboard widgets...
	async function ensureMapInitialized() {
		// Prevent concurrent initialization attempts
		if (mapInitialized || initInProgress) return;
		
		initInProgress = true;
		initAttempts++;
		console.log(`Map initialization attempt ${initAttempts}...`);
		
		try {
			// Check if Leaflet is available...
			if (typeof L === 'undefined') {
				throw new Error('Leaflet not yet available');
			}
			
			// Check if MarkerClusterGroup is available...
			if (typeof L.MarkerClusterGroup === 'undefined') {
				throw new Error('MarkerCluster plugin not yet available');
			}
			
			// Check if map container exists and has dimensions...
			const mapContainer = document.getElementById('leafletMap');
			if (!mapContainer) {
				throw new Error('Map container element not found');
			}
			
			// Get computed dimensions - container may exist but have no size yet...
			const rect = mapContainer.getBoundingClientRect();
			if (rect.width === 0 || rect.height === 0) {
				throw new Error('Map container has no dimensions yet');
			}
			
			// All checks passed - initialize the map...
			await initMap();
			mapInitialized = true;
			console.log('Map initialized successfully');
			
		} catch (error) {
			console.warn(`Map init attempt ${initAttempts} failed:`, error.message);
			
			if (initAttempts < MAX_INIT_ATTEMPTS) {
				// Exponential backoff: 100ms, 200ms, 400ms, etc. up to 2 seconds...
				const delay = Math.min(100 * Math.pow(2, initAttempts - 1), 2000);
				console.log(`Retrying in ${delay}ms...`);
				setTimeout(ensureMapInitialized, delay);
			} else {
				console.error('Max initialization attempts reached. Map failed to initialize.');
			}
		} finally {
			initInProgress = false;
		}
	}
	
	// Start initialization when DOM is ready...
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', ensureMapInitialized);
	} else {
		// DOM already ready - use requestAnimationFrame to ensure rendering is complete...
		requestAnimationFrame(() => {
			requestAnimationFrame(ensureMapInitialized);
		});
	}
	
	// Also handle visibility changes (widget may be in a hidden tab initially)...
	const mapContainer = document.getElementById('leafletMap');
	if (mapContainer && typeof IntersectionObserver !== 'undefined') {
		const visibilityObserver = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				if (entry.isIntersecting && !mapInitialized) {
					console.log('Map container became visible, attempting initialization...');
					ensureMapInitialized();
				}
			});
		}, { threshold: 0.1 });
		visibilityObserver.observe(mapContainer);
	}
	
	// Fallback: Also try when window is focused (handles tab switching)...
	window.addEventListener('focus', () => {
		if (!mapInitialized) {
			console.log('Window focused, checking map initialization...');
			setTimeout(ensureMapInitialized, 100);
		}
	});


	// ----- FUNCTIONS

	// Function to create our Leaflet map...
	function initMap() {
		// If map already exists and is valid, don't reinitialize
		if (map && map._loaded) {
			console.log('Map already initialized, skipping...');
			return;
		}
		
		// Properly cleanup existing map instance if any
		if (map) {
			try {
				map.remove();
			} catch (e) {
				console.warn('Error removing existing map:', e);
			}
			map = null;
		}
		
		// Get the container
		const container = document.getElementById('leafletMap');
		if (!container) {
			throw new Error('Map container not found');
		}
		
		// Clear any leftover Leaflet artifacts
		container.innerHTML = '';
		delete container._leaflet_id;
		
		// Create the Leaflet map
		map = L.map('leafletMap', {
			center: [0, 0],
			zoom: 3,
			minZoom: 2,
			maxZoom: 18,
			scrollWheelZoom: scrollWheelZoom,
			zoomControl: true
		});

		// Initialize bounds for later use
		bounds = L.latLngBounds();

		// Get the appropriate tile provider based on map style
		const provider = tileProviders[mapStyle] || tileProviders.silverblue;
		
		// Add the base tile layer
		baseTileLayer = L.tileLayer(provider.url, {
			attribution: provider.attribution,
			maxZoom: provider.maxZoom
		}).addTo(map);

		// Force Leaflet to recalculate size multiple times to handle flexbox timing
		// This fixes tile rendering issues when using flexbox layouts
		const invalidateSizeRepeatedly = () => {
			if (map) {
				map.invalidateSize({ animate: false });
			}
		};
		setTimeout(invalidateSizeRepeatedly, 0);
		setTimeout(invalidateSizeRepeatedly, 100);
		setTimeout(invalidateSizeRepeatedly, 300);
		setTimeout(invalidateSizeRepeatedly, 500);

		// Handle window resize to keep map properly sized
		window.addEventListener('resize', () => {
			if (map) {
				map.invalidateSize();
			}
		});

		// Redraw polylines after zoom/pan/drag completes
		map.on('moveend', () => updatePolylineEndpoints());
		map.on('zoomend', () => updatePolylineEndpoints());

		// Add custom controls after a short delay to ensure map is fully initialized
		// Using setTimeout instead of whenReady for better compatibility
		setTimeout(() => {
			// Verify map is still valid and has control corners
			if (!map || !map._controlCorners) {
				console.warn('Map not ready for controls, will retry...');
				setTimeout(addControlsAndStart, 100);
				return;
			}
			addControlsAndStart();
		}, 50);
		
		function addControlsAndStart() {
			try {
				// Add custom map controls
				addCustomControls();
				
				// Create the update status control
				createUpdateArea();
				
				// Toggle visibility of our weather options
				enableWeather();

				// Toggle hiding the options bar if set as the default
				if (hideMapOptionsByDefault) {
					document.getElementById("optionsBar").classList.remove("optionsVisible");
					document.getElementById("optionsBar").classList.add("optionsHidden");
				}

				// Load our LogicMonitor data
				waitForElm('#refreshStatusArea').then((elm) => {
					refreshGroupData();
				});
			} catch (e) {
				console.error('Error adding controls:', e);
			}
		}

		// Refresh the map data at regular intervals
		if (!developmentFlag) {
			mapDataRefresher = setInterval(function() {
				refreshGroupData(timedRefresh = true);
				console.log("Map data refreshed.");
			}, statusUpdateIntervalMinutes*1000*60);
		}
	}

	// Add custom controls to the Leaflet map
	function addCustomControls() {
		// Toggle control for options bar
		const ToggleControl = L.Control.extend({
			options: { position: 'topleft' },
			onAdd: function(map) {
				const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
				const button = L.DomUtil.create('a', 'leaflet-control-custom', container);
				button.href = '#';
				button.title = 'Toggle visibility of the map controls';
				button.innerHTML = hideMapOptionsByDefault ? optionsToggleHiddenIcon : optionsToggleVisibleIcon;
				button.style.width = '34px';
				button.style.height = '34px';
				button.style.display = 'flex';
				button.style.alignItems = 'center';
				button.style.justifyContent = 'center';
				
				L.DomEvent.disableClickPropagation(container);
				L.DomEvent.on(button, 'click', function(e) {
					L.DomEvent.preventDefault(e);
					const optionsBar = document.getElementById("optionsBar");
					if (optionsBar.classList.contains("optionsHidden")) {
						optionsBar.classList.remove("optionsHidden");
						optionsBar.classList.add("optionsVisible");
						button.innerHTML = optionsToggleVisibleIcon;
					} else {
						optionsBar.classList.remove("optionsVisible");
						optionsBar.classList.add("optionsHidden");
						button.innerHTML = optionsToggleHiddenIcon;
					}
				});
				return container;
			}
		});
		map.addControl(new ToggleControl());

		// Refresh control
		const RefreshControl = L.Control.extend({
			options: { position: 'topleft' },
			onAdd: function(map) {
				const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
				const button = L.DomUtil.create('a', 'leaflet-control-custom', container);
				button.href = '#';
				button.id = 'weatherRefreshButton';
				button.title = 'Force refresh the map data';
				button.innerHTML = '<svg viewBox="-0.5 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg" style="width:20px;height:20px;"> <path d="M7.1998 10.8799L3.9998 14.0799L0.799805 10.8799" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M17.72 6.77007C16.6086 5.63347 15.1839 4.85371 13.6275 4.53032C12.0711 4.20693 10.4536 4.35459 8.98145 4.95439C7.5093 5.5542 6.24924 6.57899 5.362 7.898C4.47476 9.21701 4.0006 10.7703 4 12.3599V14.0901" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M16.7998 13.96L19.9998 10.75L23.1998 13.96" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M6.28027 18.0801C7.39163 19.2167 8.8164 19.9962 10.3728 20.3196C11.9292 20.643 13.5467 20.4956 15.0188 19.8958C16.491 19.2959 17.751 18.2712 18.6383 16.9521C19.5255 15.6331 19.9997 14.0796 20.0003 12.49V10.76" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
				button.style.width = '34px';
				button.style.height = '34px';
				button.style.display = 'flex';
				button.style.alignItems = 'center';
				button.style.justifyContent = 'center';
				
				L.DomEvent.disableClickPropagation(container);
				L.DomEvent.on(button, 'click', function(e) {
					L.DomEvent.preventDefault(e);
					refreshGroupData();
				});
				return container;
			}
		});
		map.addControl(new RefreshControl());

		// Zoom reset control
		const ZoomResetControl = L.Control.extend({
			options: { position: 'topleft' },
			onAdd: function(map) {
				const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
				const button = L.DomUtil.create('a', 'leaflet-control-custom', container);
				button.href = '#';
				button.title = 'Reset map zoom';
				button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewBox="0 0 400 400"><g transform="translate(0,-652.36216)"><path style="fill:#000000" d="M 17.6035,652.36212 0,670.05352 l 108.5469,109.0918 -84.0235,0 0,25.0195 126.5235,0 0,-127.1563 -24.8965,0 0,84.4434 -108.5469,-109.0898 z m 364.793,0 -108.5469,109.0898 0,-84.4434 -24.8965,0 0,127.1563 126.5235,0 0,-25.0195 -84.0235,0 L 400,670.05352 382.3965,652.36212 Z M 24.5234,900.5593 l 0,25.0196 84.0235,0 L 0,1034.6708 l 17.6035,17.6914 108.5469,-109.09 0,84.4435 24.8965,0 0,-127.1564 -126.5235,0 z m 224.4297,0 0,127.1564 24.8965,0 0,-84.4435 108.5469,109.09 L 400,1034.6708 291.4531,925.5789 l 84.0235,0 0,-25.0196 -126.5235,0 z"/></g></svg>';
				button.style.width = '34px';
				button.style.height = '34px';
				button.style.display = 'flex';
				button.style.alignItems = 'center';
				button.style.justifyContent = 'center';
				
				L.DomEvent.disableClickPropagation(container);
				L.DomEvent.on(button, 'click', function(e) {
					L.DomEvent.preventDefault(e);
					resetZoom();
				});
				return container;
			}
		});
		map.addControl(new ZoomResetControl());
	}

	// Create the update status area as a Leaflet control
	function createUpdateArea() {
		const UpdateStatusControl = L.Control.extend({
			options: { position: 'topleft' },
			onAdd: function(map) {
				const container = L.DomUtil.create('div', 'leaflet-control update-status');
				container.id = 'refreshStatusArea';
				container.style.display = 'flex';
				container.style.alignItems = 'center';
				container.style.padding = '8px 12px';
				container.style.backgroundColor = 'white';
				container.style.borderRadius = '4px';
				container.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
				container.style.fontSize = '14px';
				container.style.color = 'darkblue';
				container.innerHTML = 'Updating...';
				L.DomEvent.disableClickPropagation(container);
				return container;
			}
		});
		map.addControl(new UpdateStatusControl());
		
		// Cache the reference
		_dom.refreshStatusArea = document.getElementById('refreshStatusArea');
	}

	// Function for creating & styling the map button for toggling the options bar...
	function createWeatherToggleControl(map) {
		const weatherToggle = document.createElement("button");

		weatherToggle.id = "weatherControlToggle";
		weatherToggle.style.backgroundColor = "rgb(255 255 255)";
		weatherToggle.style.border = "0";
		weatherToggle.style.borderRadius = "3px";
		weatherToggle.style.boxShadow = "0 1px 4px rgba(0,0,0,0.3)";
		// weatherToggle.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
		weatherToggle.style.cursor = "pointer";
		weatherToggle.style.fontSize = "x-large";
		weatherToggle.style.textAlign = "center";
		weatherToggle.style.margin = "10px";
		weatherToggle.style.height = "40px";
		weatherToggle.style.width = "40px";
		weatherToggle.style.verticalAlign = "middle";
		// weatherToggle.innerHTML = 'Toggle Controls';
		weatherToggle.title = "Toggle visibility of the map controls";
		if (hideMapOptionsByDefault) {
			weatherToggle.innerHTML = optionsToggleHiddenIcon;
		} else {
			weatherToggle.innerHTML = optionsToggleVisibleIcon;
		}
		weatherToggle.type = "button";

		weatherToggle.addEventListener("click", () => {
			const optionsBar = document.getElementById("optionsBar");
			if (optionsBar.classList.contains("optionsHidden")) {
				optionsBar.classList.remove("optionsHidden");
				optionsBar.classList.add("optionsVisible");
				weatherToggle.innerHTML = optionsToggleVisibleIcon;
			} else {
				optionsBar.classList.remove("optionsVisible");
				optionsBar.classList.add("optionsHidden");
				weatherToggle.innerHTML = optionsToggleHiddenIcon;
			}
		});

		return weatherToggle;
	}

	function createWeatherRefreshControl(map) {
		const weatherControls = document.createElement("button");

		weatherControls.id = "weatherRefreshButton";
		weatherControls.style.backgroundColor = "rgb(255 255 255 / 0%)";
		weatherControls.style.border = "0";
		weatherControls.style.borderRadius = "3px";
		// weatherControls.style.boxShadow = "0 1px 4px rgba(0,0,0,0.3)";
		// weatherControls.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
		weatherControls.style.cursor = "pointer";
		weatherControls.style.fontSize = "x-large";
		weatherControls.style.textAlign = "center";
		// weatherControls.style.margin = "10px";
		weatherControls.style.height = "40px";
		weatherControls.style.width = "40px";
		weatherControls.style.verticalAlign = "middle";
		// weatherControls.innerHTML = 'Toggle Controls';
		weatherControls.title = "Force refresh the map data";
		weatherControls.innerHTML = '<svg viewBox="-0.5 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M7.1998 10.8799L3.9998 14.0799L0.799805 10.8799" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M17.72 6.77007C16.6086 5.63347 15.1839 4.85371 13.6275 4.53032C12.0711 4.20693 10.4536 4.35459 8.98145 4.95439C7.5093 5.5542 6.24924 6.57899 5.362 7.898C4.47476 9.21701 4.0006 10.7703 4 12.3599V14.0901" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M16.7998 13.96L19.9998 10.75L23.1998 13.96" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M6.28027 18.0801C7.39163 19.2167 8.8164 19.9962 10.3728 20.3196C11.9292 20.643 13.5467 20.4956 15.0188 19.8958C16.491 19.2959 17.751 18.2712 18.6383 16.9521C19.5255 15.6331 19.9997 14.0796 20.0003 12.49V10.76" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
		weatherControls.type = "button";

		weatherControls.addEventListener("click", refreshGroupData);

		return weatherControls;
	}

	function createZoomResetControl(map) {
		const weatherControls = document.createElement("button");

		weatherControls.id = "weatherZoomResetButton";
		weatherControls.style.backgroundColor = "rgb(255 255 255 / 0%)";
		weatherControls.style.border = "0";
		weatherControls.style.borderRadius = "3px";
		weatherControls.style.cursor = "pointer";
		weatherControls.style.fontSize = "x-large";
		weatherControls.style.textAlign = "center";
		// weatherControls.style.margin = "10px";
		weatherControls.style.height = "40px";
		weatherControls.style.width = "40px";
		weatherControls.style.verticalAlign = "middle";
		// weatherControls.innerHTML = 'Toggle Controls';
		weatherControls.title = "Reset map zoom";
		weatherControls.innerHTML = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" width="25px" height="25px" viewBox="0 0 400 400.00001" id="svg2" version="1.1" inkscape:version="0.91 r13725" sodipodi:docname="minimize.svg"> <defs id="defs4" /> <g transform="translate(0,-652.36216)"> <path style="opacity:1;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" d="M 17.6035,652.36212 0,670.05352 l 108.5469,109.0918 -84.0235,0 0,25.0195 126.5235,0 0,-127.1563 -24.8965,0 0,84.4434 -108.5469,-109.0898 z m 364.793,0 -108.5469,109.0898 0,-84.4434 -24.8965,0 0,127.1563 126.5235,0 0,-25.0195 -84.0235,0 L 400,670.05352 382.3965,652.36212 Z M 24.5234,900.5593 l 0,25.0196 84.0235,0 L 0,1034.6708 l 17.6035,17.6914 108.5469,-109.09 0,84.4435 24.8965,0 0,-127.1564 -126.5235,0 z m 224.4297,0 0,127.1564 24.8965,0 0,-84.4435 108.5469,109.09 L 400,1034.6708 291.4531,925.5789 l 84.0235,0 0,-25.0196 -126.5235,0 z" id="minimize"> <title id="title23704">Reset map zoom</title></path></g></svg>';
		weatherControls.type = "button";

		weatherControls.addEventListener("click", resetZoom);

		return weatherControls;
	}

	function createRotateRightControl(map) {
		const weatherControls = document.createElement("button");

		weatherControls.id = "mapRotateRightButton";
		weatherControls.style.backgroundColor = "rgb(255 255 255 / 0%)";
		weatherControls.style.border = "0";
		weatherControls.style.borderRadius = "3px";
		weatherControls.style.cursor = "pointer";
		weatherControls.style.fontSize = "x-large";
		weatherControls.style.textAlign = "center";
		// weatherControls.style.margin = "10px";
		weatherControls.style.height = "30px";
		weatherControls.style.width = "30px";
		weatherControls.style.verticalAlign = "middle";
		// weatherControls.innerHTML = 'Toggle Controls';
		weatherControls.title = "Rotate Map Right";
		weatherControls.innerHTML = '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"> <path id="Path" fill="#000000" stroke="none" d="M 30.322001 21.322001 C 30.228001 21.277 30.118999 21.250999 30.003 21.250999 C 29.705 21.250999 29.448 21.423 29.323999 21.673 L 29.322001 21.677 C 27.145 26.191999 22.604 29.250999 17.348 29.250999 C 10.03 29.250999 4.097 23.318001 4.097 16 C 4.097 8.681999 10.029 2.75 17.347 2.749001 L 17.347 2.749001 C 17.358999 2.749001 17.374001 2.749001 17.389 2.749001 C 21.684999 2.749001 25.499001 4.813 27.893 8.003 L 27.917 8.036999 L 22.274 8.036999 C 21.860001 8.036999 21.524 8.373001 21.524 8.786999 C 21.524 9.201 21.860001 9.536999 22.274 9.536999 L 22.274 9.536999 L 29.346001 9.536999 C 29.365 9.536999 29.381001 9.527 29.4 9.526001 C 29.507 9.512001 29.603001 9.483 29.693001 9.442001 L 29.687 9.445 C 29.702 9.437 29.718 9.437 29.733 9.429001 C 29.754999 9.410999 29.775 9.393 29.792999 9.374001 L 29.792999 9.374001 C 29.837 9.341 29.875999 9.306 29.910999 9.265999 L 29.912001 9.264999 C 29.938999 9.232 29.965 9.195 29.986 9.156 L 29.988001 9.152 C 30.038 9.071999 30.07 8.977001 30.079 8.875 L 30.079 8.873001 C 30.086 8.848999 30.091999 8.82 30.096001 8.790001 L 30.096001 8.785999 L 30.096001 1.715 C 30.096001 1.301001 29.76 0.965 29.346001 0.965 C 28.931999 0.965 28.596001 1.301001 28.596001 1.715 L 28.596001 1.715 L 28.596001 6.485001 C 25.898001 3.275 21.881001 1.247999 17.391001 1.247999 C 17.375 1.247999 17.358999 1.247999 17.344 1.247999 L 17.346001 1.247999 C 9.201 1.25 2.6 7.853001 2.6 15.998001 C 2.6 24.143999 9.204 30.747999 17.35 30.747999 C 23.198999 30.747999 28.253 27.344 30.638 22.408001 L 30.676001 22.32 C 30.722 22.226 30.747999 22.115 30.747999 21.997999 C 30.747999 21.701 30.575001 21.444 30.325001 21.322001 L 30.320999 21.32 Z"/> </svg>';
		// weatherControls.innerHTML = '<svg viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg"> <g id="Group-copy"> <path id="Path" fill="#000000" stroke="#000000" stroke-width="2" d="M 31.638996 17.068626 C 31.183994 17.524628 31.183994 18.265625 31.638996 18.719627 L 35.817997 22.898624 C 26.449997 22.942627 17.635994 24.545628 10.962997 27.445625 C 3.893997 30.519627 -7e-06 34.722626 -7e-06 39.284626 C -7e-06 48.483627 15.904995 55.684624 36.204998 55.684624 C 56.506996 55.684624 72.410004 48.480625 72.410004 39.284626 C 72.410004 38.640625 71.886002 38.117626 71.241997 38.117626 C 70.598999 38.117626 70.073997 38.640625 70.073997 39.284626 C 70.073997 46.909626 54.562996 53.348625 36.204998 53.348625 C 17.847996 53.348625 2.335999 46.907623 2.335999 39.284626 C 2.335999 35.758625 5.821 32.228626 11.895996 29.586624 C 18.275993 26.810627 26.749996 25.273624 35.798996 25.233627 L 31.638996 29.389626 C 31.183994 29.843624 31.183994 30.584625 31.638996 31.040627 C 32.094997 31.494625 32.834995 31.494625 33.289997 31.040627 L 40.278996 24.056625 L 33.289997 17.067627 C 32.834995 16.610626 32.094997 16.610626 31.638996 17.068626 Z"/> </g> </svg>';
		weatherControls.type = "button";

		weatherControls.addEventListener("click", function() {adjustMap("rotate", -5);});

		return weatherControls;
	}

	function createRotateLeftControl(map) {
		const weatherControls = document.createElement("button");

		weatherControls.id = "mapRotateLeftButton";
		weatherControls.style.backgroundColor = "rgb(255 255 255 / 0%)";
		weatherControls.style.border = "0";
		weatherControls.style.borderRadius = "3px";
		weatherControls.style.cursor = "pointer";
		weatherControls.style.fontSize = "x-large";
		weatherControls.style.textAlign = "center";
		// weatherControls.style.margin = "10px";
		weatherControls.style.height = "30px";
		weatherControls.style.width = "30px";
		weatherControls.style.verticalAlign = "middle";
		// weatherControls.innerHTML = 'Toggle Controls';
		weatherControls.title = "Rotate Map Left";
		weatherControls.innerHTML = '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"> <path id="Path" fill="#000000" stroke="none" d="M 16 1.25 C 15.987 1.25 15.971 1.25 15.956 1.25 C 11.466 1.25 7.448 3.276001 4.769 6.464001 L 4.751 6.486 L 4.751 1.716999 C 4.751 1.302999 4.415 0.966999 4.001 0.966999 C 3.587 0.966999 3.251 1.302999 3.251 1.716999 L 3.251 1.716999 L 3.251 8.788 C 3.255 8.818001 3.261 8.845001 3.268 8.869999 L 3.267 8.865 C 3.275 8.970001 3.307 9.067001 3.358 9.15 L 3.356 9.146999 C 3.381 9.193001 3.408 9.232 3.438 9.269001 L 3.437 9.268 C 3.471 9.306 3.508 9.34 3.548 9.369999 L 3.55 9.371 C 3.57 9.390999 3.59 9.41 3.612 9.428001 L 3.613 9.429001 C 3.628 9.438 3.645 9.438 3.661 9.445999 C 3.703 9.466999 3.751 9.485001 3.802 9.497 L 3.807 9.498001 C 3.847 9.511 3.894 9.521 3.942 9.526001 L 3.945 9.526001 C 3.964 9.527 3.981 9.536999 4.001 9.536999 L 11.072 9.536999 C 11.486 9.536999 11.822 9.201 11.822 8.786999 C 11.822 8.373001 11.486 8.036999 11.072 8.036999 L 11.072 8.036999 L 5.429 8.036999 C 7.848 4.813 11.662 2.749001 15.958 2.749001 C 15.973 2.749001 15.988 2.749001 16.003 2.749001 L 16.000999 2.749001 C 23.318001 2.750999 29.247999 8.681999 29.247999 15.999001 C 29.247999 23.316 23.316 29.249001 15.998 29.249001 C 10.743 29.249001 6.203 26.190001 4.061 21.756001 L 4.027 21.677 C 3.903 21.423 3.647 21.250999 3.35 21.250999 C 2.936 21.250999 2.6 21.587 2.6 22.000999 C 2.6 22.117001 2.626 22.226999 2.674 22.325001 L 2.672 22.32 C 5.095 27.344999 10.15 30.750999 16.000999 30.750999 C 24.148001 30.750999 30.752001 24.146999 30.752001 16 C 30.752001 7.853001 24.148001 1.249001 16.002001 1.249001 L 16.002001 1.249001 Z"/> </svg>';
		weatherControls.type = "button";

		weatherControls.addEventListener("click", function() {adjustMap("rotate", 5);});

		return weatherControls;
	}

	function createRotateForwardControl(map) {
		const weatherControls = document.createElement("button");

		weatherControls.id = "mapRotateForwardButton";
		weatherControls.style.backgroundColor = "rgb(255 255 255 / 0%)";
		weatherControls.style.border = "0";
		weatherControls.style.borderRadius = "3px";
		weatherControls.style.cursor = "pointer";
		weatherControls.style.fontSize = "x-large";
		weatherControls.style.textAlign = "center";
		// weatherControls.style.margin = "10px";
		weatherControls.style.height = "30px";
		weatherControls.style.width = "30px";
		weatherControls.style.verticalAlign = "middle";
		// weatherControls.innerHTML = 'Toggle Controls';
		weatherControls.title = "Rotate Map Up";
		weatherControls.innerHTML = '<svg viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg"> <g id="Group"> <path id="Path" fill="#000000" stroke="#000000" stroke-width="2" d="M 55.341 31.229 C 54.884998 30.773998 54.144001 30.773998 53.689999 31.229 L 49.511002 35.408001 C 49.466999 26.040001 47.863998 17.225998 44.964001 10.553001 C 41.889999 3.484001 37.687 -0.410004 33.125 -0.410004 C 23.926001 -0.410004 16.725 15.494999 16.725 35.795002 C 16.725 56.097 23.929001 72 33.125 72 C 33.769001 72 34.292 71.475998 34.292 70.831993 C 34.292 70.188995 33.769001 69.663994 33.125 69.663994 C 25.5 69.663994 19.061001 54.153 19.061001 35.795002 C 19.061001 17.438 25.502001 1.926003 33.125 1.926003 C 36.651001 1.926003 40.181 5.411003 42.823002 11.486 C 45.598999 17.865997 47.136002 26.34 47.175999 35.389 L 43.02 31.229 C 42.566002 30.773998 41.825001 30.773998 41.368999 31.229 C 40.915001 31.685001 40.915001 32.424999 41.368999 32.880001 L 48.353001 39.868999 L 55.341999 32.880001 C 55.799 32.424999 55.799 31.685001 55.341 31.229 Z"/> </g> </svg>';
		weatherControls.type = "button";

		weatherControls.addEventListener("click", function() {adjustMap("tilt", 5);});

		return weatherControls;
	}

	function createRotateBackControl(map) {
		const weatherControls = document.createElement("button");

		weatherControls.id = "mapRotateBackButton";
		weatherControls.style.backgroundColor = "rgb(255 255 255 / 0%)";
		weatherControls.style.border = "0";
		weatherControls.style.borderRadius = "3px";
		weatherControls.style.cursor = "pointer";
		weatherControls.style.fontSize = "x-large";
		weatherControls.style.textAlign = "center";
		// weatherControls.style.margin = "10px";
		weatherControls.style.height = "30px";
		weatherControls.style.width = "30px";
		weatherControls.style.verticalAlign = "middle";
		// weatherControls.innerHTML = 'Toggle Controls';
		weatherControls.title = "Rotate Map Down";
		weatherControls.innerHTML = '<svg viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg"> <g id="Group-copy"> <path id="Path" fill="#000000" stroke="#000000" stroke-width="2" d="M 17.068624 40.361004 C 17.524626 40.816006 18.265623 40.816006 18.719625 40.361004 L 22.898623 36.182003 C 22.942625 45.550003 24.545628 54.364006 27.445625 61.037003 C 30.519627 68.106003 34.722626 72.000008 39.284626 72.000008 C 48.483627 72.000008 55.684624 56.095005 55.684624 35.795002 C 55.684624 15.493004 48.480625 -0.410004 39.284626 -0.410004 C 38.640625 -0.410004 38.117626 0.113998 38.117626 0.758003 C 38.117626 1.401001 38.640625 1.926003 39.284626 1.926003 C 46.909626 1.926003 53.348625 17.437004 53.348625 35.795002 C 53.348625 54.152004 46.907627 69.664001 39.284626 69.664001 C 35.758625 69.664001 32.228626 66.179001 29.586624 60.104004 C 26.810627 53.724007 25.273624 45.250004 25.233627 36.201004 L 29.389626 40.361004 C 29.843624 40.816006 30.584625 40.816006 31.040627 40.361004 C 31.494625 39.905003 31.494625 39.165005 31.040627 38.710003 L 24.056625 31.721004 L 17.067625 38.710003 C 16.610624 39.165005 16.610624 39.905003 17.068624 40.361004 Z"/> </g> </svg>';
		weatherControls.type = "button";

		weatherControls.addEventListener("click", function() {adjustMap("tilt", -5);});

		return weatherControls;
	}

	function adjustMap(mode, amount) {
		// Note: Leaflet doesn't support tilt/heading like Google Maps
		// This function is kept for compatibility but does nothing
		console.debug('adjustMap: tilt/heading not supported in Leaflet');
	}

	// Function to load our LogicMonitor data and add pins to the map...
	async function refreshGroupData(timedRefresh = false) {
		// Cancel any in-progress refresh operation
		if (_currentRefreshController) {
			_currentRefreshController.abort();
			console.debug('Previous refresh operation cancelled.');
		}
		_currentRefreshController = new AbortController();
		const refreshSignal = _currentRefreshController.signal;

		// Capture current time for tracking how long the total refresh takes...
		refreshStartTime = performance.now();

		// Get the current value of the group path filter field...
		const groupPathFilterFieldValue = _dom.customGroupFilterField.value;
		if (groupPathFilterFieldValue != "" && groupPathFilterFieldValue != groupPathFilter) {
			groupPathFilter = groupPathFilterFieldValue;

		// The filter changed so clear any previous markers from the map...
		clearAllMarkers();
		} else if (groupPathFilterFieldValue == "") {
			// The user cleared the field, so reset it back to the initial value...
			groupPathFilter = initialGroupPathFilter;
		}
		_dom.customGroupFilterField.value = groupPathFilter;

		// Get current state of the severity checkboxes on the toolbar...
		showCleared = _dom.showCleared.checked;
		showWarnings = _dom.showWarnings.checked;
		showErrors = _dom.showErrors.checked;
		showCriticals = _dom.showCriticals.checked;
		showSDT = _dom.showSDT.checked;
		// If the user unchecked all the severities it'd essentially query all severities, so re-check all the checkboxes if that happens...
		if (!showCleared && !showWarnings && !showErrors && !showCriticals && !showSDT) {
			_dom.showCleared.checked = true;
			_dom.showWarnings.checked = true;
			_dom.showErrors.checked = true;
			_dom.showCriticals.checked = true;
			_dom.showSDT.checked = true;
		}
		// Get current state of the auto-zoom checkbox on the toolbar...
		autoResetMapOnRefresh = _dom.autoZoom.checked;

		// If there was a wildcard in the group path then do a "like" search, otherwise search for an exact match...
		let pathOperator = ":";
		if (groupPathFilter.includes("*")) {
			pathOperator = "~";
		}

		// Temporarily disable the toolbar fields to prevent user from refreshing before previous refresh is complete...
		_dom.mapOptionsArea.classList.add("disabled");
		// Cache refresh button reference if not already cached
		if (!_dom.weatherRefreshButton) {
			_dom.weatherRefreshButton = document.getElementById("weatherRefreshButton");
		}
		if (_dom.weatherRefreshButton) {
			_dom.weatherRefreshButton.classList.add("disabled");
		}

		// Clear any previously fetched data...
		groupData = [];
		// For tracking how many groups to fetch & pagination...
		let totalGroups = 1000;
		let offset = 0;

		// Cache refresh status area reference if not already cached
		if (!_dom.refreshStatusArea) {
			_dom.refreshStatusArea = document.getElementById("refreshStatusArea");
		}
		// Display our progress to the user...
		_dom.refreshStatusArea.innerHTML = loadingSpinner + "&nbsp;Updating";
		_dom.refreshStatusArea.style.display = "flex";

		// Prepare to call the LogicMonitor API method...
		const httpVerb = "GET";

		// List of fields to fetch...
		let fieldList = "alertStatus,displayName,description,id,hostStatus,name,sdtStatus,numOfHosts,numOfAWSDevices,numOfAzureDevices,numOfGcpDevices,numOfKubernetesDevices,numOfDirectDevices,numOfSubGroups,customProperties,autoProperties";
		// Only fetch custom & inherited properties on full refreshes...
		if (cachedAddresses.length == 0 || pollCount > fullRefreshInterval) {
			fullRefresh = true;
			fieldList = fieldList + ",inheritedProperties,systemProperties";
			pollCount = 0;
		}

		// Determine whether to fetch groups or resources...
		let deviceFilter = "";
		let resourcePath = "/device/groups";
		if (mapSourceType != "groups") {
			resourcePath = "/device/devices";
			deviceFilter = ",deviceType:0|4|18|19";
			if (mapSourceType == "services") {
				deviceFilter = ",deviceType:6";
			}
		}

		// Set our severity filters to query...
		let statusFilter = "";
		let statusArray = [];
		// if (!showCleared && showWarnings && showErrors && showCriticals) {
		if (showCleared) {
			statusArray.push("none");
		}
		if (showWarnings) {
			statusArray.push("*warn*");
		}
		if (showErrors) {
			statusArray.push("*error*");
		}
		if (showCriticals) {
			statusArray.push("*critical*");
		}
		if (statusArray.length > 0) {
			statusFilter = ',alertStatus:' + '"' + statusArray.join("|") + '"';
		}
		if (!showSDT) {
			statusFilter = statusFilter + ',sdtStatus:"none-none-*"';
		}

		// Reset our zoom level when the filter options change...
		if (centerCalculated && autoZoom && !timedRefresh) {
			centerCalculated = false;
		}

		// Start fetching data from LM that have location in custom properties, paginating the data as necessary...
		try {
			while (offset < totalGroups) {
				// let queryParams = `?v=3&size=1000&offset=${offset}&fields=${fieldList}&filter=fullPath${pathOperator}"${groupPathFilter}"${statusFilter}${deviceFilter}`;
				let queryParams = `?v=3&size=1000&offset=${offset}&fields=${fieldList}&filter=customProperties.name:"location",fullPath${pathOperator}"${groupPathFilter}"${statusFilter}${deviceFilter}`;

				// The 'fullpath' attribute only exists for group queries - for devices & services we'll use 'system.groups' instead...
				if (mapSourceType != "groups") {
					if (groupPathFilter != "*") {
						// Strip off leading or trailing asterisks since they're not needed in this case...
						let tmpPathFilter = groupPathFilter.replace(/^\*/, "").replace(/\*$/, "");
						if (tmpPathFilter != "") {
							// queryParams = '?v=3&size=1000&offset=' + offset + '&filter=systemProperties~"{\\"name\\":\\"system.groups\\",\\"value\\":\\"*' + tmpPathFilter + '*\\"}"' + statusFilter + deviceFilter;
							queryParams = '?v=3&size=1000&offset=' + offset + '&filter=customProperties.name:"location",systemProperties~"{\\"name\\":\\"system.groups\\",\\"value\\":\\"*' + tmpPathFilter + '*\\"}"' + statusFilter + deviceFilter;
						}
					} else {
						queryParams = '?v=3&size=1000&offset=' + offset + '&filter=customProperties.name:"location"' + statusFilter + deviceFilter;
					}
				}

				// Call the LogicMonitor API to get a list of groups...
				const markerData = await LMClient({
					resourcePath: resourcePath,
					queryParams: queryParams,
					httpVerb: httpVerb,
					postBody: null,
					apiVersion: '3',
					signal: refreshSignal, // Allow cancellation of in-progress requests
				});
				// Process the group data we received...
				// console.debug('Group request succeeded with JSON response', markerData);

				if (markerData.total != 0) {
					if (markerData.total != totalGroups) {
						totalGroups = markerData.total;
					}

					groupData = groupData.concat(markerData.items);

					offset = groupData.length;

					// Display our progress to the user...
					_dom.refreshStatusArea.innerHTML = loadingSpinner + "&nbsp;Updating: " + offset + " of " + totalGroups + " (" + Math.round(offset/totalGroups*100) + "%)";
					// _dom.refreshStatusArea.innerHTML = "Updating: " + Math.round(offset/totalGroups*100) + "%";
				} else {
					// Indicate that no results were found...
					if (offset == 0) {
						console.debug('No results found');
						_dom.refreshStatusArea.innerHTML = "<span class='noResultMessage'>No results</span>";
						totalGroups = -1; // Stop the loop
						// Re-enable the toolbar fields...
						_dom.mapOptionsArea.classList.remove("disabled");
						if (_dom.weatherRefreshButton) {
							_dom.weatherRefreshButton.classList.remove("disabled");
						}

						// Clear any previous markers from the map...
						clearAllMarkers();

						// Reset the map zoom...
						bounds = L.latLngBounds();
						resetZoom();
						centerCalculated = false;
					}
				}
			}


			// Start fetching data from LM that have location in inherited properties, paginating the data as necessary...
			// Inherited properties don't apply to groups, so skip this if not looking at resources and/or services...
			// console.debug('totalGroups: ' + totalGroups);
			if (mapSourceType != "groups" && pollInheritedLocations) {
				offset = 0;
				let tmpTotalGroups = 1000;
				while (offset < tmpTotalGroups) {
					// let queryParams = `?v=3&size=1000&offset=${offset}&fields=${fieldList}&filter=fullPath${pathOperator}"${groupPathFilter}"${statusFilter}${deviceFilter}`;
					let queryParams = `?v=3&size=1000&offset=${offset}&fields=${fieldList}&filter=inheritedProperties.name:"location",fullPath${pathOperator}"${groupPathFilter}"${statusFilter}${deviceFilter}`;

					// The 'fullpath' attribute only exists for group queries - for devices & services we'll use 'system.groups' instead...
					if (groupPathFilter != "*") {
						// Strip off leading or trailing asterisks since they're not needed in this case...
						let tmpPathFilter = groupPathFilter.replace(/^\*/, "").replace(/\*$/, "");
						if (tmpPathFilter != "") {
							// queryParams = '?v=3&size=1000&offset=' + offset + '&filter=systemProperties~"{\\"name\\":\\"system.groups\\",\\"value\\":\\"*' + tmpPathFilter + '*\\"}"' + statusFilter + deviceFilter;
							queryParams = '?v=3&size=1000&offset=' + offset + '&filter=inheritedProperties.name:"location",systemProperties~"{\\"name\\":\\"system.groups\\",\\"value\\":\\"*' + tmpPathFilter + '*\\"}"' + statusFilter + deviceFilter;
						}
					} else {
						queryParams = '?v=3&size=1000&offset=' + offset + '&filter=inheritedProperties.name:"location"' + statusFilter + deviceFilter;
					}
					// console.debug("Query params for inherited locations: " + queryParams);

					// Call the LogicMonitor API to get a list of groups...
					const markerData = await LMClient({
						resourcePath: resourcePath,
						queryParams: queryParams,
						httpVerb: httpVerb,
						postBody: null,
						apiVersion: '3',
						signal: refreshSignal, // Allow cancellation of in-progress requests
					});
					// Process the group data we received...
					// console.debug('Group request succeeded with JSON response', markerData);

					// console.debug("Inherited locations found: " + markerData.total);
					if (markerData.total != 0) {
						if (markerData.total != tmpTotalGroups) {
							tmpTotalGroups = markerData.total;
							if (totalGroups >= 0) {
								totalGroups = totalGroups + markerData.total;
							} else {
								totalGroups = markerData.total;
							}
						}

						groupData = groupData.concat(markerData.items);

						offset = groupData.length;

						// Display our progress to the user...
						_dom.refreshStatusArea.innerHTML = loadingSpinner + "&nbsp;Updating: " + offset + " of " + tmpTotalGroups + " (" + Math.round(offset/tmpTotalGroups*100) + "%)";
						// _dom.refreshStatusArea.innerHTML = "Updating: " + Math.round(offset/totalGroups*100) + "%";
					} else {
						// We're done so stop the loop...
						// console.debug("We're done fetching inherited locations");
						tmpTotalGroups = 0;
						offset = totalGroups;
						break;
					}
				}
				// console.debug("totalGroups: " + totalGroups + " / tmpTotalGroups: " + tmpTotalGroups + " / offset: " + offset);
			}
		} catch (error) {
			// Silently handle aborted requests (user triggered a new refresh)
			if (error.name === 'AbortError') {
				console.debug('Refresh operation was cancelled.');
				return; // Exit early, new refresh will take over
			}
			console.error('Error fetching group data:', error);
			_dom.refreshStatusArea.innerHTML = `<span class='noResultMessage'>Error loading data: ${error.message || 'Unknown error'}</span>`;
			totalGroups = -1; // Stop the loop on error
			// Re-enable the toolbar fields...
			_dom.mapOptionsArea.classList.remove("disabled");
			if (_dom.weatherRefreshButton) {
				_dom.weatherRefreshButton.classList.remove("disabled");
			}
		}

		// If we've finished fetching all the group/resource data...
		if (offset == totalGroups) {
			// console.debug('Total groups processed: ' + totalGroups);
			// Reset our progress indicator...
			_dom.refreshStatusArea.innerHTML = "";
			_dom.refreshStatusArea.style.display = "none";
			// Re-enable the toolbar fields...
			_dom.mapOptionsArea.classList.remove("disabled");
			if (_dom.weatherRefreshButton) {
				_dom.weatherRefreshButton.classList.remove("disabled");
			}

			// Prepare geocoding for translating a street address to latitude & longitude...
			// Using Nominatim (OpenStreetMap) geocoding service as a free alternative
			const geocoder = {
				geocode: async function(request, callback) {
					const address = encodeURIComponent(request.address);
					try {
						const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${address}&limit=1`, {
							headers: { 'User-Agent': 'BetterMapWidget/4.0' }
						});
						const data = await response.json();
						if (data && data.length > 0) {
							const result = {
								geometry: {
									location: {
										lat: () => parseFloat(data[0].lat),
										lng: () => parseFloat(data[0].lon)
									}
								}
							};
							callback([result], 'OK');
						} else {
							callback([], 'ZERO_RESULTS');
						}
					} catch (error) {
						callback([], 'ERROR');
					}
				}
			};
			const parser = new DOMParser();

			let itemsProcessed = 0;

			// Clear any previous markers from the map...
			clearAllMarkers();

			// For use in zooming the map to encompass all our markers on initial draw...
			bounds = L.latLngBounds();

			// Start looping through the groups...
			groupData.forEach((thisItem) => {
				let groupID = thisItem.id;
				let highestSeverity = "";
				let sdtStatus = "";

				// Parse the alarm status...
				let alertStatusArray = thisItem.alertStatus.match(/([\w]+)-([\w]+)-([\w]+)/);
				if (alertStatusArray) {
					let alertStatus = alertStatusArray[1];
					let alertSeverity = alertStatusArray[2];

					if ((alertSeverity == "warn" && highestSeverity == "") || (alertSeverity == "error" && highestSeverity != "critical") || (alertSeverity == "critical")) {
						highestSeverity = alertSeverity;
					}
				}
				// Parse the SDT status...
				let sdtStatusArray = thisItem.sdtStatus.match(/([\w]+)-([\w]+)-([\w]+)/);
				if (sdtStatusArray[1].toLowerCase() == "sdt" || sdtStatusArray[2].toLowerCase() == "sdt") {
					sdtStatus = "sdt";
				}

				// Variables for each severity...
				// The SVG icon for the group's severity...
				let sevIcon = clearedIcon;
				// We'll use the pin's z-index to reflect the group's severity for use with marker clustering...
				let pinIndex = 0;
				if (highestSeverity != "") {
					if (highestSeverity == "warn") {
						sevIcon = warningIcon;
						pinBG = "#f5ca1d";
						pinBorder = "#967c14";
						pinIndex = 1;
					} else if (highestSeverity == "error") {
						sevIcon = errorIcon;
						pinBG = "#ff8c00";
						pinBorder = "#ac5101";
						pinIndex = 2;
					} else if (highestSeverity == "critical") {
						sevIcon = criticalIcon;
						pinBG = "#e0351b";
						pinBorder = "#9a2614";
						pinIndex = 3;
					}
				} else {
					highestSeverity = "clear";
				}

				// If in SDT...
				if (sdtStatus == "sdt") {
					highestSeverity = "sdt";
					sevIcon = sdtIcon;
					pinBG = "#00a1fe";
					pinBorder = "#00a1fe";
					pinIndex = 4;
				}

				// Get the group's location (hopefully an address)...
				let address = "";
				let latProp = "";
				let lngProp = "";
				alreadyGeocoded = false;
				// First check to see if the location is in custom properties (defined on the group/resource itself)...
				if (fullRefresh) {
					try {
						address = thisItem.customProperties.find((locationProp) => locationProp.name.toLowerCase() === "location").value;

						// See if there are custom properties for latitude and longitude...
						if (!ignoreLatLongProps) {
							latProp = thisItem.customProperties.find((locationProp) => locationProp.name.toLowerCase() === "latitude");
							lngProp = thisItem.customProperties.find((locationProp) => locationProp.name.toLowerCase() === "longitude");
							if (latProp && lngProp) {
								let latVal = Number(latProp.value);
								let lngVal = Number(lngProp.value);
								if (latVal > -90 && latVal < 90 && lngVal > -180 && lngVal < 180) {
									// address = `${latProp.value}, ${lngProp.value}`;
									alreadyGeocoded = true;
								}
							}
						}
					} catch(e) {
						try {
							// If not found in custom properties, try to get it from inherited properties...
							address = thisItem.inheritedProperties.find((locationProp) => locationProp.name.toLowerCase() === "location").value;

							// See if there are inherited properties for latitude and longitude...
							if (!ignoreLatLongProps) {
								latProp = thisItem.inheritedProperties.find((locationProp) => locationProp.name.toLowerCase() === "latitude");
								lngProp = thisItem.inheritedProperties.find((locationProp) => locationProp.name.toLowerCase() === "longitude");
								if (latProp && lngProp) {
									let latVal = Number(latProp.value);
									let lngVal = Number(lngProp.value);
									if (latVal > -90 && latVal < 90 && lngVal > -180 && lngVal < 180) {
										// address = `${latProp.value}, ${lngProp.value}`;
										alreadyGeocoded = true;
									}
								}
							}
						} catch(y) {
							// console.log("No address found for " + thisItem.name);
							// totalGroups = totalGroups - 1;
						}
					}
				}

				// Remove any extraneous characters from the address...
				address = address.trim().replaceAll("\t", "").replaceAll("\n", ", ");

				resolveAddress(thisItem, address);

				// Resolve locations to latitude/longitude...
				async function resolveAddress(thisItem, address) {
					// console.debug('Resolving address for ' + thisItem.name + ': ' + address);
					// Check to see if we've already geocoded this group's address and that the address hasn't changed...
					if (cachedAddresses[thisItem.id] && cachedAddresses[thisItem.id].address == address) {
						// console.debug('Address already geocoded for ' + thisItem.name + ': ' + address);
						// Call the subfunction to add the group to the map...
						plotMarker(thisItem, cachedAddresses[thisItem.id].lat, cachedAddresses[thisItem.id].lng, cachedAddresses[thisItem.id].address);
					} else {
						if (alreadyGeocoded) {
							// console.debug('Address already geocoded as custom properties for ' + thisItem.name + ': ' + address);
							// Cache the address for reuse...
							cachedAddresses[thisItem.id] = {lat: Number(latProp.value), lng: Number(lngProp.value), address: address};
							debouncedSaveCache();
							// Call the subfunction to add the group to the map...
							plotMarker(thisItem, cachedAddresses[thisItem.id].lat, cachedAddresses[thisItem.id].lng, cachedAddresses[thisItem.id].address);
						} else {
							// See if the location is a latitude/longitude...
							const coodinateRE = /^([\-]*[\d]+[\.\d]+)[ ,]+([\-]*[\d]+[\.\d]+)$/;
							let match = coodinateRE.exec(address);
							let latVal = null;
							let lngVal = null;
							if (match && match.length == 3) {
								try {
									latVal = Number(match[1]);
									lngVal = Number(match[2]);
								} catch(e) {};
								// It appears we have a latitude & longitude. Cache them for reuse...
								latVal = Number(match[1]);
								lngVal = Number(match[2]);
							}
							// Ensure the latitude and longitude are valid...
							if (latVal && lngVal && latVal > -90 && latVal < 90 && lngVal > -180 && lngVal < 180 && latVal != 0 && lngVal != 0) {
								// console.debug('Latitude & longitude found for ' + thisItem.name + ': ' + match[1] + ', ' + match[2]);
								cachedAddresses[thisItem.id] = {lat: Number(match[1]), lng: Number(match[2]), address: address};
								debouncedSaveCache();
								// Call the subfunction to add the group to the map...
								plotMarker(thisItem, cachedAddresses[thisItem.id].lat, cachedAddresses[thisItem.id].lng, address);
							} else {
								// Attempt to geocode the address...
								geocoder.geocode( {'address': address}, function(results, status) {
									if (status == 'OK') {
										// Grab the longitude/latitude from the results...
										let geocodedLocation = results[0].geometry.location;

										// Cache these coordinates for reuse later...
										cachedAddresses[thisItem.id] = {lat: Number(geocodedLocation.lat()), lng: Number(geocodedLocation.lng()), address: address};
										debouncedSaveCache();
										// Call the subfunction to add the group to the map...
										plotMarker(thisItem, cachedAddresses[thisItem.id].lat, cachedAddresses[thisItem.id].lng, address);
									} else {
										// We weren't provided a resolvable address, so deduct this item from our overall count...
										totalGroups = totalGroups - 1;
										// We still call the `plotMarker` even though there's no marker to plot in case this was the last one to process...
										plotMarker(thisItem, null, null, null);
									}
								});
							}
						}
					}
				}

				// Subfunction to add markers to the map...
				async function plotMarker(thisItem, lat, lng, address) {
					if (address != null) {
						// Start creating content for the group's map pin...
						const content = document.createElement("div");
						let customContent = "";

						// Search the item's properties for any specified to display...
						if (displayProps != "") {
							const propList = displayProps.split(",");
							propList.forEach(thisProp => {
								// Check the custom properties...
								if (thisItem.customProperties) {
									let propArray = thisItem.customProperties.filter(item => item.name == thisProp.trim());
									if (propArray.length == 1) {
										customContent = `${customContent}<div class="customItem"><span class="customItemName">${propArray[0].name}</span>: ${propArray[0].value}</div>`;
									// Check inherited properties...
									} else if (thisItem.inheritedProperties) {
										propArray = thisItem.inheritedProperties.filter(item => item.name == thisProp.trim());
										if (propArray.length == 1) {
											customContent = `${customContent}<div class="customItem"><span class="customItemName">${propArray[0].name}</span>: ${propArray[0].value}</div>`;
										// Check auto properties...
										} else if (thisItem.autoProperties) {
											propArray = thisItem.autoProperties.filter(item => item.name == thisProp.trim());
											if (propArray.length == 1) {
												customContent = `${customContent}<div class="customItem"><span class="customItemName">${propArray[0].name}</span>: ${propArray[0].value}</div>`;
											}
										}
									}
								}
							});
							if (customContent != "") {
								customContent = `<div class="customItemArea">${customContent}</div>`;
							}
						}


						// Look to see if connecting line info has been provided...
						if (thisItem.autoProperties) {
							let propArray = thisItem.autoProperties.filter(item => item.name == connectionInfoProp);
							if (propArray.length == 1) {
								// Multiple connections to an endpoint can be specifed by separating them with a semicolon...
								const connectionItems = propArray[0].value.split(";");

								// Loop through the connections...
								connectionItems.forEach(thisConnection => {
									// Split the comma-separated parameters...
									let params = thisConnection.split(",");

									if (params.length > 0) {
										let tmp = {};
										tmp.connectionName = params[0].trim();
										tmp.datasourceID = params[1].trim();
										tmp.instanceID = params[2].trim();
										tmp.deviceIDSource = thisItem.id;
										tmp.deviceIDConnected = params[3].trim();
										// TODO: Maybe add support for another parameter for the source device ID to support group connections.

										lineData[`${tmp.deviceIDSource}${tmp.deviceIDConnected}`] = tmp;
										// lineData[tmp.deviceIDSource + ":" + tmp.deviceIDConnected] = tmp;
									}
								});
							}
						}

						content.classList.add("group");
						// The pin's z-index gets overwritten when clicked to show details, so capture the original severity in the pin's metadata...
						content.dataset.severity = pinIndex;
						// Create the content shown when the pin is clicked...
						if (mapSourceType == "groups") {
							// Capture the group's description...
							let groupDescription = thisItem.description;
							// If the group doesn't have a description then fallback to showing the address...
							if (groupDescription == "") {
								groupDescription = address;
							}

							content.innerHTML = `
								<div class="icon ${highestSeverity}">
									${sevIcon}
								</div>
								<div class="details">
									<div class="groupName"><a href="/santaba/uiv4/resources/treeNodes/t-dg,id-${thisItem.id}?source=details" target="_blank">${thisItem.name}</a></div>
									<div class="description">${groupDescription}${customContent}</div>
									<div class="features">
										<div title="${thisItem.numOfHosts} Standard Devices">
											<svg xmlns="http://www.w3.org/2000/svg" class="infoDialogIcon" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M160 96C124.7 96 96 124.7 96 160L96 224C96 259.3 124.7 288 160 288L480 288C515.3 288 544 259.3 544 224L544 160C544 124.7 515.3 96 480 96L160 96zM376 168C389.3 168 400 178.7 400 192C400 205.3 389.3 216 376 216C362.7 216 352 205.3 352 192C352 178.7 362.7 168 376 168zM432 192C432 178.7 442.7 168 456 168C469.3 168 480 178.7 480 192C480 205.3 469.3 216 456 216C442.7 216 432 205.3 432 192zM160 352C124.7 352 96 380.7 96 416L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 416C544 380.7 515.3 352 480 352L160 352zM376 424C389.3 424 400 434.7 400 448C400 461.3 389.3 472 376 472C362.7 472 352 461.3 352 448C352 434.7 362.7 424 376 424zM432 448C432 434.7 442.7 424 456 424C469.3 424 480 434.7 480 448C480 461.3 469.3 472 456 472C442.7 472 432 461.3 432 448z"/></svg>

											<span>${thisItem.numOfHosts}</span>
										</div>
										<div title="${thisItem.numOfAWSDevices + thisItem.numOfAzureDevices + thisItem.numOfGcpDevices} Cloud Devices">
											<svg xmlns="http://www.w3.org/2000/svg" class="infoDialogIcon" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M32 400C32 479.5 96.5 544 176 544L480 544C550.7 544 608 486.7 608 416C608 364.4 577.5 319.9 533.5 299.7C540.2 286.6 544 271.7 544 256C544 203 501 160 448 160C430.3 160 413.8 164.8 399.6 173.1C375.5 127.3 327.4 96 272 96C192.5 96 128 160.5 128 240C128 248 128.7 255.9 129.9 263.5C73 282.7 32 336.6 32 400z"/></svg>
											<span>${thisItem.numOfAWSDevices + thisItem.numOfAzureDevices + thisItem.numOfGcpDevices}</span>
										</div>
										<div title="${thisItem.numOfKubernetesDevices} Kubernetes Devices">
											<svg xmlns="http://www.w3.org/2000/svg" class="infoDialogIcon" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M401.8 269.7L450.4 227.2C464.2 246.5 473.8 269.1 477.8 293.4L413.4 297.7C411 287.6 407 278.2 401.8 269.7zM541.9 289.2C536.6 250.4 521.3 214.7 498.7 184.9L499.5 184.2C513 172.4 513.7 151.6 501 139C488.3 126.4 467.6 127 455.8 140.5L455.1 141.3C425.3 118.7 389.6 103.4 350.8 98.1L350.9 97C352.1 79.1 337.9 64 320 64C302.1 64 287.9 79.2 289.1 97L289.2 98.1C250.4 103.4 214.7 118.7 184.9 141.3L184.2 140.5C172.4 127 151.6 126.3 139 139C126.4 151.7 127 172.4 140.5 184.2L141.3 184.9C118.7 214.7 103.4 250.4 98.1 289.2L97 289.1C79.1 287.9 64 302.1 64 320C64 337.9 79.2 352.1 97 350.9L98.1 350.8C103.4 389.6 118.7 425.3 141.3 455.1L140.5 455.8C127 467.6 126.3 488.4 139 501C151.7 513.6 172.4 513 184.2 499.5L184.9 498.7C214.7 521.3 250.4 536.6 289.2 541.9L289.1 543C287.9 560.9 302.1 576 320 576C337.9 576 352.1 560.8 350.9 543L350.8 541.9C389.6 536.6 425.3 521.3 455.1 498.7L455.8 499.5C467.6 513 488.3 513.7 501 501C513.7 488.3 513 467.6 499.5 455.8L498.7 455.1C521.3 425.3 536.6 389.6 541.9 350.8L543 350.9C560.9 352.1 576 337.9 576 320C576 302.1 560.8 287.9 543 289.1L541.9 289.2zM227.2 189.6C246.5 175.8 269.1 166.2 293.4 162.1L297.7 226.5C287.7 228.9 278.2 232.9 269.7 238.1L227.2 189.5zM162.2 293.4C166.3 269 175.9 246.5 189.7 227.2L238.3 269.7C233 278.2 229.1 287.7 226.7 297.7L162.3 293.4zM189.7 412.8C175.9 393.5 166.3 370.9 162.2 346.6L226.6 342.3C229 352.4 233 361.8 238.2 370.3L189.6 412.8zM293.5 477.8C269.1 473.7 246.6 464.1 227.3 450.4L269.8 401.8C278.3 407.1 287.8 411 297.8 413.4L293.5 477.8zM412.9 450.4C393.6 464.2 371 473.8 346.7 477.8L342.4 413.4C352.4 411 361.9 407 370.4 401.8L412.9 450.4zM477.9 346.6C473.8 371 464.2 393.5 450.5 412.8L401.9 370.3C407.2 361.7 411.1 352.3 413.5 342.3L477.9 346.6zM412.9 189.7L370.4 238.3C361.8 233 352.4 229.1 342.4 226.7L346.7 162.3C371.1 166.4 393.6 176 412.9 189.8zM320 288C337.7 288 352 302.3 352 320C352 337.7 337.7 352 320 352C302.3 352 288 337.7 288 320C288 302.3 302.3 288 320 288z"/></svg>
											<span>${thisItem.numOfKubernetesDevices}</span>
										</div>
										<div class="drillDownButton" title="Open group in new tab">
											<a href="/santaba/uiv4/resources/treeNodes/t-dg,id-${thisItem.id}?source=details" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" class="infoDialogIcon" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path fill="white" d="M384 64C366.3 64 352 78.3 352 96C352 113.7 366.3 128 384 128L466.7 128L265.3 329.4C252.8 341.9 252.8 362.2 265.3 374.7C277.8 387.2 298.1 387.2 310.6 374.7L512 173.3L512 256C512 273.7 526.3 288 544 288C561.7 288 576 273.7 576 256L576 96C576 78.3 561.7 64 544 64L384 64zM144 160C99.8 160 64 195.8 64 240L64 496C64 540.2 99.8 576 144 576L400 576C444.2 576 480 540.2 480 496L480 416C480 398.3 465.7 384 448 384C430.3 384 416 398.3 416 416L416 496C416 504.8 408.8 512 400 512L144 512C135.2 512 128 504.8 128 496L128 240C128 231.2 135.2 224 144 224L224 224C241.7 224 256 209.7 256 192C256 174.3 241.7 160 224 160L144 160z"/></svg></a>
										</div>
									</div>
								</div>
							`;
						} else {
							// Capture the group's description...
							let groupDescription = thisItem.description;
							// If the group doesn't have a description then fallback to showing the address...
							if (groupDescription == "") {
								groupDescription = "Host:" + thisItem.name + "<br/>Address: " + cachedAddresses[groupID].address;
							}

							content.innerHTML = `
								<div class="icon ${highestSeverity}">
									${sevIcon}
								</div>
								<div class="details">
									<div class="groupName"><a href="/santaba/uiv4/resources/treeNodes/t-d,id-${thisItem.id}?source=details&tab=alert" target="_blank">${thisItem.displayName}</a></div>
									<div class="description">${groupDescription}${customContent}</div>
									<div class="features">
										<div class="drillDownButton" title="Open group in new tab">
											<a href="/santaba/uiv4/resources/treeNodes/t-d,id-${thisItem.id}?source=details&tab=alert" target="_blank" class="link"><svg xmlns="http://www.w3.org/2000/svg" class="infoDialogIcon" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path fill="white" d="M384 64C366.3 64 352 78.3 352 96C352 113.7 366.3 128 384 128L466.7 128L265.3 329.4C252.8 341.9 252.8 362.2 265.3 374.7C277.8 387.2 298.1 387.2 310.6 374.7L512 173.3L512 256C512 273.7 526.3 288 544 288C561.7 288 576 273.7 576 256L576 96C576 78.3 561.7 64 544 64L384 64zM144 160C99.8 160 64 195.8 64 240L64 496C64 540.2 99.8 576 144 576L400 576C444.2 576 480 540.2 480 496L480 416C480 398.3 465.7 384 448 384C430.3 384 416 398.3 416 416L416 496C416 504.8 408.8 512 400 512L144 512C135.2 512 128 504.8 128 496L128 240C128 231.2 135.2 224 144 224L224 224C241.7 224 256 209.7 256 192C256 174.3 241.7 160 224 160L144 160z"/></svg></a>
										</div>
									</div>
								</div>
							`;
						}

					// Add this group's pin to the map using Leaflet...
					const lat = cachedAddresses[groupID].lat;
					const lng = cachedAddresses[groupID].lng;
					
					// Create a Leaflet divIcon with the same HTML content
					const icon = L.divIcon({
						className: 'group-marker',
						html: content.outerHTML,
						iconSize: [27, 35],
						iconAnchor: [13, 35],
						popupAnchor: [0, -35]
					});
					
					let marker = L.marker([lat, lng], {
						icon: icon,
						title: thisItem.name,
						zIndexOffset: pinIndex
					});
					
					// Store deviceID on marker for polyline lookups...
					marker.deviceID = thisItem.id;
					// Store position for compatibility
					marker.position = { lat: lat, lng: lng };

					// Open info window when marker is clicked...
					marker.on('click', () => {
						toggleHighlight(marker, thisItem)
					});

					// Add reference to this pin for use by the clustering algorithm or if we need to modify them later...
					markers.push(marker);
					// Also add to Map for O(1) lookups by device ID
					markersByDeviceID.set(thisItem.id, marker);

					// Add this marker to map's bounding box (for initial zooming)...
					bounds.extend([lat, lng]);

					itemsProcessed = itemsProcessed + 1;
					}
					// console.log("itemsProcessed: " + itemsProcessed + " / totalGroups: " + totalGroups);

					// If all items have been processed, initialize the marker cluster...
					if (itemsProcessed == totalGroups) {
						// If this is the first time drawing the map, center the map based on our markers...
						if (!centerCalculated || (timedRefresh && autoResetMapOnRefresh)) {
							resetZoom();
							centerCalculated = true;
						}

					if (!disableClustering) {
						// Reset our marker clustering on refreshes...
						if (clusterer) {
							map.removeLayer(clusterer);
						}
						// Initialize Leaflet marker clusters with custom donut chart icons...
						clusterer = L.markerClusterGroup({
							maxClusterRadius: 120,
							spiderfyOnMaxZoom: true,
							showCoverageOnHover: false,
							zoomToBoundsOnClick: false,
							iconCreateFunction: function(cluster) {
								const childMarkers = cluster.getAllChildMarkers();
								return createDonutClusterIcon(childMarkers);
							}
						});
						
						// Add all markers to the cluster group
						markers.forEach(m => clusterer.addLayer(m));
						map.addLayer(clusterer);
						
						// Handle cluster click to show summary
						clusterer.on('clusterclick', function(e) {
							showClusterSummary(e.layer);
						});
						
						// Redraw connecting lines when clusters change
						clusterer.on('animationend', () => {
							updatePolylineEndpoints();
						});
					} else {
						// If clustering is disabled, add markers directly to the map
						markers.forEach(m => m.addTo(map));
					}

					// Plot any connecting lines between resources...
					if (mapSourceType == "resources") {
						// Clear any existing connecting lines before drawing new ones
						clearAllPolylines();
						lineData.forEach(thisConnection => {
							// Look to see if connecting point exists on the map...
							if (cachedAddresses[thisConnection.deviceIDConnected]) {
								// Plot the connection on the map...
								plotConnection(thisConnection);
							}
						});
						// After drawing, ensure endpoints point to current marker/cluster locations
						updatePolylineEndpoints();
					}

						// Our refresh is now complete, so capture how long it took...
						let refreshEndTime = performance.now();
						console.debug(`Total map refresh time: ${refreshEndTime - refreshStartTime} milliseconds`);
						pollCount = pollCount + 1;
						if (fullRefresh) {
							fullRefresh = false;
						}

						// Note: Leaflet doesn't support tilt/heading like Google Maps
					}
				}
			});
		}
	}

	// Function to fetch connection status & plot connecting lines on the map...
	async function plotConnection(connection) {
		// Establish coordinates of the line start and end...
		const tmpCoords = [
			{ lat: cachedAddresses[connection.deviceIDSource].lat, lng: cachedAddresses[connection.deviceIDSource].lng},
			{ lat: cachedAddresses[connection.deviceIDConnected].lat, lng: cachedAddresses[connection.deviceIDConnected].lng}
		];

		// Fetch the current alert status of the defined instance...
		let resourcePath = `/device/devices/${connection.deviceIDSource}/devicedatasources/${connection.datasourceID}/instances/${connection.instanceID}`;
		let httpVerb = "GET";
		const instanceData = await LMClient({
			resourcePath: resourcePath,
			queryParams: "",
			httpVerb: httpVerb,
			postBody: null,
			apiVersion: '3',
		});
		// console.debug('Instance status succeeded with JSON response', instanceData);

		// Process the data we received...
		if (instanceData) {
			let alertStatus = "OK";
			let alertSeverity = "clear";
			let sdtStatus = "";
			let connectionColor = "#85c25d";
			// Parse the alarm status...
			let alertStatusArray = instanceData.alertStatus.match(/([\w]+)-([\w]+)-([\w]+)/);
			if (alertStatusArray) {
				alertStatus = alertStatusArray[1];
				alertSeverity = alertStatusArray[2];
			}

			// Determine color by severity...
			if (alertSeverity != "") {
				if (alertSeverity == "warn") {
					connectionColor = "#f5ca1d";
					alertStatus = "Warning";
				} else if (alertSeverity == "error") {
					connectionColor = "#ff8c00";
					alertStatus = "Error";
				} else if (alertSeverity == "critical") {
					connectionColor = "#e0351b";
					alertStatus = "Critical";
				}
			}

			// Parse the SDT status...
			let sdtStatusArray = instanceData.sdtStatus.match(/([\w]+)-([\w]+)-([\w]+)/);
			if (sdtStatusArray[1].toLowerCase() == "sdt" || sdtStatusArray[2].toLowerCase() == "sdt") {
				sdtStatus = "sdt";
			}
			// If in SDT...
			if (sdtStatus == "sdt") {
				connectionColor = "#00a1fe";
			}

			// Plot the line on the map using Leaflet...
			const latLngs = [
				[tmpCoords[0].lat, tmpCoords[0].lng],
				[tmpCoords[1].lat, tmpCoords[1].lng]
			];
			
			const thisPath = L.polyline(latLngs, {
				color: connectionColor,
				weight: connectingLineWeight,
				opacity: 1.0
			}).addTo(map);

			// Track polyline with source/target IDs so we can redraw to clusters
			polylines.push({
				polyline: thisPath,
				sourceDeviceID: connection.deviceIDSource,
				targetDeviceID: connection.deviceIDConnected,
				originalCoords: tmpCoords
			});

			// Show connection info on hover using Leaflet popup...
			const popupContent = `<strong>${connection.connectionName}</strong><br/>Connection alert status: <a href="/santaba/uiv4/resources/treeNodes/t-i,id-${connection.instanceID}?source=details&tab=alert" target="_blank" title="Click to view alerts" style="border: 0;">${alertStatus}</a>`;
			
			thisPath.bindPopup(popupContent, {
				closeButton: false,
				offset: [0, -10]
			});

			thisPath.on('mouseover', function(e) {
				this.openPopup(e.latlng);
			});
			thisPath.on('mouseout', function(e) {
				this.closePopup();
			});
			thisPath.on('click', function(e) {
				window.open("/santaba/uiv4/resources/treeNodes/t-i,id-" + connection.instanceID + "?source=details&tab=alert");
			});
			// Ensure new polylines handle clusters properly...
			updatePolylineEndpoints();
		}
	}

	// Function for showing/hiding a group's detail when clicked...
	function toggleHighlight(markerView, group) {
		// Close any open cluster popup...
		if (clusterInfoWindow) {
			map.closePopup(clusterInfoWindow);
			clusterInfoWindow = null;
		}
		
		// If clicking the same marker that's already open, close it
		if (markerInfoWindow && markerInfoWindow.markerId === markerView.deviceID) {
			map.closePopup(markerInfoWindow);
			markerInfoWindow = null;
			return;
		}
		
		// Close any existing marker popup
		if (markerInfoWindow) {
			map.closePopup(markerInfoWindow);
		}
		
		// Get the info content from the marker's icon HTML
		const iconHtml = markerView.options.icon.options.html;
		const tempDiv = document.createElement('div');
		tempDiv.innerHTML = iconHtml;
		const contentClone = tempDiv.querySelector('.group').cloneNode(true);
		// Add highlight class to apply the expanded styling
		contentClone.classList.add('highlight');
		// Make sure the details are visible
		const detailsEl = contentClone.querySelector('.details');
		if (detailsEl) {
			detailsEl.style.display = 'flex';
		}
		
		// Create and open the Leaflet popup
		markerInfoWindow = L.popup({
			offset: [0, -20],
			maxWidth: 400,
			className: 'marker-popup'
		})
		.setLatLng(markerView.getLatLng())
		.setContent(contentClone.outerHTML)
		.openOn(map);
		
		markerInfoWindow.markerId = markerView.deviceID; // Track which marker this is for
	}

	// Function processing status of Fetch calls...
	function status(response) {
		if (response.status >= 200 && response.status < 300) {
			return Promise.resolve(response);
		} else {
			return Promise.reject(new Error(response.statusText));
		}
	}


	// Pre-processor for JSON responses from Fetch calls...
	function json(response) {
		return response.json();
	}

	// Create a Leaflet divIcon for clusters with donut chart visualization
	function createDonutClusterIcon(childMarkers) {
		const count = childMarkers.length;
		
		// Create objects to hold per-severity metrics...
		const severityCounts = new Map([["4",0],["3",0],["2",0],["1",0],["0",0]]);
		const severityPercents = new Map([["4",0],["3",0],["2",0],["1",0]]);
		const severityOffsets = new Map([["4",0],["3",0],["2",0],["1",0]]);

		// Get counts of clustered pins by severity (using zIndexOffset for Leaflet markers)...
		childMarkers.forEach((marker) => {
			const zIndex = marker.options.zIndexOffset || 0;
			const severity = zIndex > 0 ? zIndex.toString() : "0";
			severityCounts.set(severity, (severityCounts.get(severity) || 0) + 1);
		});

		// Calculate sizes & offsets for our chart...
		const baseOffset = 25;
		let offsetSum = 0;
		severityPercents.forEach((value, key) => {
			const percent = (severityCounts.get(key)/count) * 100;
			severityPercents.set(key, percent);

			if (percent > 0) {
				if (offsetSum == 0) {
					severityOffsets.set(key, baseOffset);
				} else {
					const offset = (100 - offsetSum) + baseOffset;
					severityOffsets.set(key, offset);
				}
				offsetSum = offsetSum + percent;
			}
		});

		// Create an SVG donut chart representing severities of clustered pins...
		const svgContent = `
			<svg fill="#0000ff" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 42 42" class="donut" width="45" height="45">
				<filter id="gaussian-blur-${count}" x="-20%" y="-20%" width="140%" height="140%">
					<feDropShadow dx="0" dy="0.4" stdDeviation="1.3" flood-opacity="0.7" />
				</filter>
				<g filter="url(#gaussian-blur-${count})">
					<circle class="donut-hole" cx="21" cy="21" r="15.91549430918954" fill="#fff"></circle>
					<circle class="donut-ring" cx="21" cy="21" r="15.91549430918954" fill="transparent" stroke="#85c25d" stroke-width="7"></circle>
					<circle class="donut-segment" cx="21" cy="21" r="15.91549430918954" fill="transparent" stroke="#00a1fe" stroke-width="7" stroke-dasharray="${severityPercents.get("4")} ${100-severityPercents.get("4")}" stroke-dashoffset="${severityOffsets.get("4")}"></circle>
					<circle class="donut-segment" cx="21" cy="21" r="15.91549430918954" fill="transparent" stroke="#e0351b" stroke-width="7" stroke-dasharray="${severityPercents.get("3")} ${100-severityPercents.get("3")}" stroke-dashoffset="${severityOffsets.get("3")}"></circle>
					<circle class="donut-segment" cx="21" cy="21" r="15.91549430918954" fill="transparent" stroke="#ff8c00" stroke-width="7" stroke-dasharray="${severityPercents.get("2")} ${100-severityPercents.get("2")}" stroke-dashoffset="${severityOffsets.get("2")}"></circle>
					<circle class="donut-segment" cx="21" cy="21" r="15.91549430918954" fill="transparent" stroke="#f5ca1d" stroke-width="7" stroke-dasharray="${severityPercents.get("1")} ${100-severityPercents.get("1")}" stroke-dashoffset="${severityOffsets.get("1")}"></circle>
				</g>
				<text x="21" y="21" text-anchor="middle" dominant-baseline="central" fill="rgba(0,0,0,0.9)" font-size="10" font-family="Arial, sans-serif">${count}</text>
			</svg>`;

		return L.divIcon({
			className: 'cluster-donut',
			html: svgContent,
			iconSize: [45, 45],
			iconAnchor: [22, 22]
		});
	}

	// Show cluster summary popup when a cluster is clicked
	function showClusterSummary(cluster) {
		const childMarkers = cluster.getAllChildMarkers();
		const count = childMarkers.length;
		
		// Create objects to hold per-severity metrics...
		const severityCounts = new Map([["4",0],["3",0],["2",0],["1",0],["0",0]]);
		
		// Get device details from markers
		const deviceDetails = childMarkers.map(marker => {
			const zIndex = marker.options.zIndexOffset || 0;
			const severity = zIndex > 0 ? zIndex.toString() : "0";
			severityCounts.set(severity, (severityCounts.get(severity) || 0) + 1);
			
			// Parse marker content to get device info
			const contentDiv = document.createElement('div');
			contentDiv.innerHTML = marker.options.icon.options.html;
			const iconDiv = contentDiv.querySelector('.icon');
			const nameLink = contentDiv.querySelector('.groupName a');
			
			let status = 'clear';
			let sdtStatus = '';
			let statusRank = 0;
			if (iconDiv && iconDiv.classList.contains('critical')) {
				status = 'critical';
				statusRank = 4;
			} else if (iconDiv && iconDiv.classList.contains('error')) {
				status = 'error';
				statusRank = 3;
			} else if (iconDiv && iconDiv.classList.contains('warn')) {
				status = 'warning';
				statusRank = 2;
			}
			if (iconDiv && iconDiv.classList.contains('sdt')) {
				sdtStatus = ' <span class="sdtNote">(in SDT)</span>';
				status = 'sdt';
				statusRank = 1;
			}

			return {
				name: nameLink ? nameLink.textContent : 'Unknown',
				link: nameLink ? nameLink.href : '#',
				status,
				sdtStatus,
				statusRank,
				position: marker.getLatLng()
			};
		});

		// Sort the resources by status, then alphabetically...
		deviceDetails.sort((a,b) => (b.statusRank - a.statusRank || a.name.localeCompare(b.name)));

		// Calculate bounds for the cluster...
		const clusterBounds = L.latLngBounds(deviceDetails.map(d => d.position));

		const popupContent = `
			<div class="mapInfoPopupWindow">
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
					<div style="font-weight: 600; font-size: 14px;">Cluster Summary</div>
					<button onclick="if(clusterInfoWindow){map.closePopup(clusterInfoWindow)};if(markerInfoWindow){map.closePopup(markerInfoWindow);markerInfoWindow=null};map.fitBounds([[${clusterBounds.getSouth()}, ${clusterBounds.getWest()}], [${clusterBounds.getNorth()}, ${clusterBounds.getEast()}]])" style="
						padding: 6px 12px;
						background: #1a73e8;
						color: white;
						border: none;
						border-radius: 4px;
						font-size: 13px;
						cursor: pointer;
						display: flex;
						align-items: center;
						gap: 6px;
						transition: background 0.2s;
					" onmouseover="this.style.background='#1557b0'" onmouseout="this.style.background='#1a73e8'">
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
							<circle cx="11" cy="11" r="8"/>
							<line x1="21" y1="21" x2="16.65" y2="16.65"/>
							<line x1="11" y1="8" x2="11" y2="14"/>
							<line x1="8" y1="11" x2="14" y2="11"/>
						</svg>
						Zoom into Cluster
					</button>
				</div>
				<div style="display: grid; gap: 8px; margin-bottom: 16px;">
					<div style="display: flex; align-items: center; gap: 8px;">
						<div style="width: 12px; height: 12px; border-radius: 50%; background: #e0351b;"></div>
						<span>Critical: ${severityCounts.get("3") || 0}</span>
					</div>
					<div style="display: flex; align-items: center; gap: 8px;">
						<div style="width: 12px; height: 12px; border-radius: 50%; background: #ff8c00;"></div>
						<span>Error: ${severityCounts.get("2") || 0}</span>
					</div>
					<div style="display: flex; align-items: center; gap: 8px;">
						<div style="width: 12px; height: 12px; border-radius: 50%; background: #f5ca1d;"></div>
						<span>Warning: ${severityCounts.get("1") || 0}</span>
					</div>
					<div style="display: flex; align-items: center; gap: 8px;">
						<div style="width: 12px; height: 12px; border-radius: 50%; background: #85c25d;"></div>
						<span>Clear: ${severityCounts.get("0") || 0}</span>
					</div>
					<div style="display: flex; align-items: center; gap: 8px;">
						<div style="width: 12px; height: 12px; border-radius: 50%; background: #00a1fe;"></div>
						<span>SDT: ${severityCounts.get("4") || 0}</span>
					</div>
				</div>
				<div style="border-top: 1px solid #eee; padding-top: 12px;">
					<div style="font-weight: 600; font-size: 14px; margin-bottom: 8px;">${mapSourceType.replace(/^./, char => char.toUpperCase())} (${count})</div>
					<div style="display: grid; gap: 4px;">
						${deviceDetails.map(device => `
							<div style="display: flex; align-items: center; padding: 4px 8px; background: color-mix(in srgb, var(--${device.status}-color) 10%, white 30%); border-radius: 4px; gap: 8px; max-height: 25px;">
								<div style="width: 8px; height: 8px; border-radius: 50%; background: var(--${device.status}-color); flex-shrink: 0;"></div>
								<a href="${device.link}"
								   target="_blank"
								   style="color: #1a73e8; text-decoration: none; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"
								   onmouseover="this.style.textDecoration='underline'"
								   onmouseout="this.style.textDecoration='none'">
									${device.name}${device.sdtStatus}
								</a>
							</div>
						`).join('')}
					</div>
				</div>
			</div>
		`;

		// Close any existing popups
		if (clusterInfoWindow) {
			map.closePopup(clusterInfoWindow);
		}
		if (markerInfoWindow) {
			map.closePopup(markerInfoWindow);
			markerInfoWindow = null;
		}

		// Create and open the popup
		clusterInfoWindow = L.popup({
			maxWidth: 400,
			className: 'cluster-popup'
		})
		.setLatLng(cluster.getLatLng())
		.setContent(popupContent)
		.openOn(map);
	}

	// Function to enable the weather overlays when the appropriate checkbox is selected...
	function enableWeather() {
		const weatherCheckbox = document.getElementById("weather");
		const optionsElement = document.getElementById("weatherOptions");
		const showClearedElement = document.getElementById("showCleared");

		if (weatherCheckbox.checked) {
			// Show the overlay options...
			optionsElement.style.display = "inline-flex";
			// Add the weather overlays...
			initWeather();
		} else {
			// Clear the timer that refreshes the weather...
			weatherRefresher = null;
			// Remove any previous weather/overlay layers...
			if (weatherTileLayer && map.hasLayer(weatherTileLayer)) {
				map.removeLayer(weatherTileLayer);
				weatherTileLayer = null;
			}
			if (overlayLayer && map.hasLayer(overlayLayer)) {
				map.removeLayer(overlayLayer);
				overlayLayer = null;
			}
			if (hurricaneLayer && map.hasLayer(hurricaneLayer)) {
				map.removeLayer(hurricaneLayer);
				hurricaneLayer = null;
			}
			if (aqiLayer && map.hasLayer(aqiLayer)) {
				map.removeLayer(aqiLayer);
				aqiLayer = null;
			}
			// Hide the overlay options...
			optionsElement.style.display = "none";
		}
	}

	// Initialize the RainViewer API...
	async function initWeather() {
		try {
			const response = await fetch("https://api.rainviewer.com/public/weather-maps.json");
			if (!response.ok) {
				throw new Error(`RainViewer API error: ${response.status} ${response.statusText}`);
			}
			// Store the API response for re-use purposes in memory...
			rvAPIData = await response.json();
			addWeatherLayer();
		} catch (error) {
			console.error("Failed to fetch RainViewer weather data:", error);
		}

		// Refresh the weather data at regular intervals (using the 'weatherRefreshMinutes' variable set near the top of this script)...
		weatherRefresher = setInterval(async function() {
			try {
				const response = await fetch("https://api.rainviewer.com/public/weather-maps.json");
				if (response.ok) {
					rvAPIData = await response.json();
				}
			} catch (error) {
				console.error("Failed to refresh weather data:", error);
			}
			addWeatherLayer();
			console.log("Weather maps refreshed.");
		}, weatherRefreshMinutes*1000*60);
	}

	// Get the latest radar frame from RainViewer...
	function initRainViewerData() {
		rvMapFrames = rvAPIData.radar.past;
		if (rvAPIData.radar.nowcast) {
			rvMapFrames = rvMapFrames.concat(rvAPIData.radar.nowcast);
			rvLastPastFramePosition = rvAPIData.radar.past.length - 1;
		}
	}

	// Function to add weather & other optional overlays to the map...
	async function addWeatherLayer() {
		const weatherCheckbox = document.getElementById("weather");
		const optionsElement = document.getElementById("weatherOptions");

		if (weatherCheckbox.checked) {
			const mapType = document.querySelector('input[name="weatherType"]:checked').value;
			const optionalMapType = document.querySelector('input[name="otherWeatherOverlays"]:checked').value;

			// Remove any previous weather tile layer...
			if (weatherTileLayer && map.hasLayer(weatherTileLayer)) {
				map.removeLayer(weatherTileLayer);
				weatherTileLayer = null;
			}

			// Add RainViewer layer if appropriate...
			if (mapType == "radar") {
				// Get the latest radar frame from RainViewer...
				initRainViewerData();

				// The following three lines really only apply if we use RainViewer's satellite imagery...
				let colorScheme = rvOptionKind == 'satellite' ? 0 : rvOptionColorScheme;
				let smooth = rvOptionKind == 'satellite' ? 0 : rvOptionSmoothData;
				let snow = rvOptionKind == 'satellite' ? 0 : rvOptionSnowColors;

				// Create the Leaflet tile layer for RainViewer...
				if (rvAPIData.host && rvMapFrames.length > 0) {
					const tileUrl = rvAPIData.host + rvMapFrames[rvLastPastFramePosition].path + '/256/{z}/{x}/{y}/' + colorScheme + '/' + smooth + '_' + snow + '.png';
					weatherTileLayer = L.tileLayer(tileUrl, {
						opacity: weatherOpacity,
						attribution: 'Weather data &copy; <a href="https://www.rainviewer.com/">RainViewer</a>'
					}).addTo(map);
				}

			// Show NEXRAD layers if appropriate...
			} else if (mapType.match(/(nexrad|q2)/g)) {
				// Create the Leaflet tile layer for NEXRAD...
				const nexradUrl = 'https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/' + mapType + '/{z}/{x}/{y}.png?' + Date.now();
				weatherTileLayer = L.tileLayer(nexradUrl, {
					opacity: weatherOpacity,
					attribution: 'NEXRAD &copy; <a href="https://mesonet.agron.iastate.edu/">Iowa Environmental Mesonet</a>'
				}).addTo(map);

			// Show OpenWeather layers if appropriate...
			} else if (mapType != "" && openWeatherMapsAPIKey.length >= 32) {
				// Create the Leaflet tile layer for OpenWeatherMap...
				const owmUrl = 'https://tile.openweathermap.org/map/' + mapType + '/{z}/{x}/{y}.png?appid=' + openWeatherMapsAPIKey;
				weatherTileLayer = L.tileLayer(owmUrl, {
					opacity: weatherOpacity,
					maxZoom: 9,
					attribution: 'Weather &copy; <a href="https://openweathermap.org/">OpenWeatherMap</a>'
				}).addTo(map);
			}

			// Look to see if we should add wildfire into the map...
			if (optionalMapType == "us-fires") {
				// Remove any previous overlay layer...
				if (overlayLayer && map.hasLayer(overlayLayer)) {
					map.removeLayer(overlayLayer);
					overlayLayer = null;
				}

				// Load the wildfire data from the ArcGIS site...
				const usWildfireUrl = `https://services9.arcgis.com/RHVPKKiFTONKtxq3/arcgis/rest/services/USA_Wildfires_v1/FeatureServer/1/query?where=CurrentDateAge+<%3D+7&outFields=*&f=geojson&ts=${Date.now()}`;
				
				// Australian bushfire data from ArcGIS (near real-time bushfire boundaries)...
				const auWildfireUrl = `https://services-ap1.arcgis.com/ypkPEy1AmwPKGNNv/arcgis/rest/services/Near_Real_Time_Bushfire_Boundaries_view/FeatureServer/3/query?where=0%3D0&geometryType=esriGeometryPolyline&units=esriSRUnit_Meter&outFields=*&returnGeometry=true&f=pgeojson&ts=${Date.now()}`;

				// Fetch both US and Australian wildfire data in parallel...
				Promise.all([
					fetch(usWildfireUrl).then(response => response.ok ? response.json() : null).catch(() => null),
					fetch(auWildfireUrl).then(response => response.ok ? response.json() : null).catch(() => null)
				]).then(([usData, auData]) => {
					// Combine all features
					const allFeatures = [];
					
					// Add US wildfire data if available...
					if (usData && usData.features) {
						usData.features.forEach(feature => {
							feature.properties = feature.properties || {};
							feature.properties._fireSource = 'US';
							allFeatures.push(feature);
						});
						console.debug(`US wildfires loaded: ${usData.features.length} features`);
					}
					
					// Add Australian wildfire data if available...
					if (auData && auData.features) {
						auData.features.forEach(feature => {
							feature.properties = feature.properties || {};
							feature.properties._fireSource = 'AU';
							allFeatures.push(feature);
						});
						console.debug(`Australian bushfires loaded: ${auData.features.length} features`);
					}

					// Create a combined GeoJSON FeatureCollection
					const combinedData = {
						type: 'FeatureCollection',
						features: allFeatures
					};

					// Create Leaflet GeoJSON layer with wildfire styling
					overlayLayer = L.geoJSON(combinedData, {
						style: {
							fillColor: 'red',
							fillOpacity: 0.5,
							weight: 1,
							color: 'salmon'
						},
						onEachFeature: function(feature, layer) {
							const props = feature.properties;
							let infoContent = '';
							
							if (props._fireSource === 'AU') {
								// Australian bushfire info display...
								let fireName = props.fire_name || "(unknown)";
								let fireType = props.fire_type || "(not available)";
								let ignitionDate = props.ignition_date;
								if (ignitionDate == null) {
									ignitionDate = "(not available)";
								} else if (typeof ignitionDate === 'number') {
									ignitionDate = new Date(ignitionDate).toLocaleDateString('en-AU');
								}
								let perimKm = props.perim_km;
								if (perimKm == null) {
									perimKm = "(not available)";
								} else {
									perimKm = Number(perimKm).toLocaleString('en-AU', numFormatOptions) + ' km';
								}
								let state = props.state || "(not available)";
								let agency = props.agency || "(not available)";
								
								infoContent = '<div style="line-height:1.35;overflow:hidden;color:black;">' +
									'<span style="font-weight:700;">Bushfire &quot;' + fireName + '&quot;</span><br/>' +
									'<br/><b>Fire Type:</b> ' + fireType +
									'<br/><b>Ignition Date:</b> ' + ignitionDate +
									'<br/><b>Perimeter:</b> ' + perimKm +
									'<br/><b>State:</b> ' + state +
									'<br/><b>Agency:</b> ' + agency +
									'</div>';
							} else {
								// US wildfire info display...
								let comments = props.Comments || "(comments not available)";
								let acres = props.GISAcres;
								if (acres == null) {
									acres = "(not available)";
								} else {
									acres = Number(acres).toLocaleString('en-US', numFormatOptions);
								}
								let fireCategory = props.FeatureCategory || "(not available)";
								
								infoContent = '<div style="line-height:1.35;overflow:hidden;white-space:nowrap;color:black;">' +
									'<span style="font-weight:700;">Wildfire &quot;' + props.IncidentName + '&quot;</span><br/>' +
									comments + '<br/><br/>Calculated Acres: ' + acres +
									'<br/>Category: ' + fireCategory +
									'<br/>Days Since Last GIS Update: ' + props.CurrentDateAge +
									'<br/>GIS Map Method: ' + props.MapMethod +
									'</div>';
							}
							
							layer.bindPopup(infoContent);
							
							if (showWildfireInfoEvent == "mouseover") {
								layer.on('mouseover', function(e) {
									this.openPopup(e.latlng);
								});
								layer.on('mouseout', function(e) {
									this.closePopup();
								});
							}
						}
					}).addTo(map);
				}).catch(error => {
					console.error('Error loading wildfire data:', error);
				});
			// Look to see if we should add power outages to the map...
			} else if (optionalMapType == "us-poweroutages") {
				// USA Today power outage data URL (fetched via CORS proxy)...
				const usaTodayDataURL = `https://data.usatoday.com/media/jsons/power/active/national_powerout_slider_data.js`;
				const corsProxy = 'https://corsproxy.io/?';
				// US Counties GeoJSON with FIPS codes (from plotly datasets)...
				const countiesGeoJsonURL = 'https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json';
				const usaTodayTotalCustomersURL = 'https://data.usatoday.com/media/jsons/power/active/national_powerout_slider_total.js';

				try {
					// Clear any previous overlay layer...
					if (overlayLayer && map.hasLayer(overlayLayer)) {
						map.removeLayer(overlayLayer);
						overlayLayer = null;
					}
					// Clear any previous earthquake contour lines...
					if (parent.mmiContourLines) {
						parent.mmiContourLines.forEach(line => {
							if (map.hasLayer(line)) map.removeLayer(line);
						});
						parent.mmiContourLines = [];
					}

					// Fetch both data sources in parallel...
					const [countiesResponse, outageResponse] = await Promise.all([
						fetch(countiesGeoJsonURL),
						fetch(corsProxy + encodeURIComponent(usaTodayDataURL + `?v=${Date.now()}`))
					]);

					if (!countiesResponse.ok) {
						throw new Error(`Counties GeoJSON fetch error: ${countiesResponse.status}`);
					}
					if (!outageResponse.ok) {
						throw new Error(`Power outage data fetch error: ${outageResponse.status}`);
					}

					// Parse the counties GeoJSON...
					const countiesGeoJson = await countiesResponse.json();

					// Parse USA Today data (it's a JS file with variable assignment, not pure JSON)
					// Format: var PowerOutagesJSON = { "type": "FeatureCollection", "features":[...] };
					// Properties: n=name, o=outage count, c=percentage, f=FIPS code, m=time index
					// Note: The highest m value represents the current data, lower values are historical.
					const outageText = await outageResponse.text();

					// First pass: determine the maximum 'm' value (current time index) from the data
					// This value can vary, so we dynamically detect it from the first county's data pattern
					const mValueRegex = /"m"\s*:\s*(\d+)/g;
					let maxTimeIndex = 0;
					let mMatch;
					while ((mMatch = mValueRegex.exec(outageText)) !== null) {
						const mValue = parseInt(mMatch[1], 10) || 0;
						if (mValue > maxTimeIndex) {
							maxTimeIndex = mValue;
						}
					}
					const CURRENT_TIME_INDEX = maxTimeIndex;
					console.debug(`Detected maximum time index (m) value: ${CURRENT_TIME_INDEX}`);

					// Extract properties from the USA Today data using regex
					// We only need the properties, not the geometry (which references undefined variables)
					const outageDataByFips = {};
					const propsRegex = /"properties":\s*\{\s*"n"\s*:\s*"([^"]+)"\s*,\s*"o"\s*:\s*"([^"]+)"\s*,\s*"c"\s*:\s*([\d.]+)\s*,\s*"f"\s*:\s*"(\d+)"\s*,\s*"m"\s*:\s*(\d+)/g;
					let match;

					while ((match = propsRegex.exec(outageText)) !== null) {
						const [_, name, outageCount, percentage, fips, timeIndex] = match;
						const timeIdx = parseInt(timeIndex, 10) || 0;

						// Only keep entries where m equals the maximum (current data)
						if (timeIdx === CURRENT_TIME_INDEX) {
							outageDataByFips[fips] = {
								name: name,
								outageCount: parseInt(outageCount.replace(/,/g, ''), 10) || 0,
								percentage: parseFloat(percentage) || 0,
								fips: fips
							}
						}
					}

					console.debug(`Parsed ${Object.keys(outageDataByFips).length} counties with current outage data (m=${CURRENT_TIME_INDEX}) from USA Today`);

					// Merge outage data into the counties GeoJSON by FIPS code...
					let countiesWithOutages = 0;
					countiesGeoJson.features.forEach(feature => {
						const fips = feature.id; // plotly dataset uses 'id' for FIPS code
						const outageData = outageDataByFips[fips];

						if (outageData) {
							feature.properties.OutageCount = outageData.outageCount;
							feature.properties.PercentAffected = outageData.percentage;
							feature.properties.CountyName = outageData.name;
							countiesWithOutages++;
						} else {
							feature.properties.OutageCount = 0;
							feature.properties.PercentAffected = 0;
							feature.properties.CountyName = feature.properties.NAME || 'Unknown County';
						}
					});

					console.debug(`US power outages loaded: ${countiesWithOutages} counties have active outages`);

					// Create Leaflet GeoJSON layer with styling based on outage percentage...
					overlayLayer = L.geoJSON(countiesGeoJson, {
						style: function(feature) {
							let percentAffected = feature.properties.PercentAffected || 0;
							let strokeColor = "#0000002e";
							let strokeOpacity = 0.1;
							let fillColor = "transparent";
							let fillOpacity = 0.0;
							
							if (percentAffected > 0) {
								strokeColor = "salmon";
								fillColor = "red";
								fillOpacity = Math.min(percentAffected / 100, 0.8);
							}

							return {
								fillColor: fillColor,
								fillOpacity: fillOpacity,
								weight: 1,
								color: strokeColor,
								opacity: strokeOpacity
							};
						},
						onEachFeature: function(feature, layer) {
							const countyName = feature.properties.CountyName || 'Unknown County';
							const outageCount = feature.properties.OutageCount || 0;
							const percentAffected = feature.properties.PercentAffected || 0;

							// Calculate donut chart values
							const circumference = 219.91;
							const filledAmount = (percentAffected / 100) * circumference;
							const donutChart = `
								<svg width="100" height="100" viewBox="0 0 100 100" style="display:block;margin:10px auto;">
									<circle cx="50" cy="50" r="35" fill="none" stroke="#e0e0e0" stroke-width="12"/>
									<circle cx="50" cy="50" r="35" fill="none" stroke="#dc3545" stroke-width="12"
										stroke-dasharray="${filledAmount} ${circumference - filledAmount}"
										stroke-linecap="round"
										transform="rotate(-90 50 50)"/>
									<text x="50" y="50" text-anchor="middle" dominant-baseline="middle"
										font-size="16" font-weight="bold" fill="#333">${percentAffected.toFixed(1)}%</text>
								</svg>
							`;

							const popupContent = `
								<div style="line-height:1.5;overflow:hidden;white-space:nowrap;color:#333;">
									<h3 style="margin:0;">${countyName} Power Outages</h3>
									${donutChart}
									<p style="padding:5px 0;">
										Customers Without Power: <strong>${outageCount.toLocaleString()}</strong> (${percentAffected.toFixed(1)}%)
									</p>
									<p style="font-size:11px; color:#777; margin: 0;">
										Data source: <a href="https://data.usatoday.com/national-power-outage-map-tracker/" target="_blank" style="color:#0085c4; text-decoration: none;">USA Today</a>
									</p>
								</div>
							`;

							layer.bindPopup(popupContent, { maxWidth: 350 });

							// Highlight counties on mouseover
							layer.on('mouseover', function(e) {
								this.setStyle({ weight: 3, opacity: 0.5 });
								this.bringToFront();
							});
							layer.on('mouseout', function(e) {
								overlayLayer.resetStyle(this);
							});
						}
					}).addTo(map);

				} catch (error) {
					console.error("Failed to fetch power outage data:", error);
				}
			} else if (optionalMapType == "earthquakes") {
				// Clear any previous overlay layer...
				if (overlayLayer && map.hasLayer(overlayLayer)) {
					map.removeLayer(overlayLayer);
					overlayLayer = null;
				}
				// Clear any previous earthquake contour lines...
				if (parent.mmiContourLines) {
					parent.mmiContourLines.forEach(line => {
						if (map.hasLayer(line)) map.removeLayer(line);
					});
					parent.mmiContourLines = [];
				}

				// Load the earthquake data for the past day from the USGS site...
				// More info about this source of earthquake data can be found at: https://publicapis.io/usgs-earthquake-hazards-program-api
				let earthquakeUrl;
				if (quakeMode == "time") {
					earthquakeUrl = `https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_week.geojson?ts=${Date.now()}`;
				} else {
					earthquakeUrl = `https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_day.geojson?ts=${Date.now()}`;
				}
				
				const earthquakeResponse = await fetch(earthquakeUrl);
				const earthquakeData = await earthquakeResponse.json();
				console.debug(`Earthquake data loaded: ${earthquakeData.features?.length || 0} earthquakes`);

				// Function to calculate icon styling based on earthquake properties...
				function getEarthquakeIcon(feature) {
					let alertColor = "crimson";
					let iconOpacity = 0.5;

					if (quakeMode == "time") {
						let now = new Date();
						let quakeTime = new Date(feature.properties.time);
						let timeDiff = now - quakeTime;
						let timeScale = (86400 * 12) / timeDiff * 100;
						if (timeScale > iconOpacity) {
							iconOpacity = timeScale;
						}
					} else {
						let mag = feature.properties.mag;
						let magScale = 1 - ((7 - mag) / 10);
						if (magScale > 0.5) {
							iconOpacity = magScale;
						}
					}

					// Build SVG icon URL
					const iconUrl = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 302.836 302.836'%3E%3Cpath d='M271 256a15 15 0 0 1-15 15 15 15 0 0 1-15-15 15 15 0 0 1 15-15 15 15 0 0 1 15 15z' style='opacity:${iconOpacity};fill:${alertColor};fill-opacity:${iconOpacity}' transform='translate(-104.582 -104.582)'/%3E%3Cpath d='M256 139.29c-64.44 0-116.71 52.27-116.71 116.71S191.56 372.71 256 372.71 372.71 320.44 372.71 256 320.44 139.29 256 139.29zm0 3c62.818 0 113.71 50.892 113.71 113.71 0 62.818-50.892 113.71-113.71 113.71-62.818 0-113.71-50.892-113.71-113.71 0-62.818 50.892-113.71 113.71-113.71z' style='opacity:${iconOpacity};fill:${alertColor};fill-opacity:.55' transform='translate(-104.582 -104.582)'/%3E%3Cpath d='M256 214.266c-22.996 0-41.734 18.738-41.734 41.734 0 22.996 18.738 41.734 41.734 41.734 22.996 0 41.734-18.738 41.734-41.734 0-22.996-18.738-41.734-41.734-41.734zm0 9c18.132 0 32.734 14.602 32.734 32.734S274.132 288.734 256 288.734 223.266 274.132 223.266 256s14.602-32.734 32.734-32.734z' style='opacity:${iconOpacity};fill:${alertColor};fill-opacity:${iconOpacity}' transform='translate(-104.582 -104.582)'/%3E%3Cpath d='M256 189.678c-36.594 0-66.322 29.728-66.322 66.322s29.728 66.322 66.322 66.322 66.322-29.728 66.322-66.322-29.728-66.322-66.322-66.322zm0 6c33.35 0 60.322 26.971 60.322 60.322 0 33.35-26.971 60.322-60.322 60.322-33.35 0-60.322-26.971-60.322-60.322 0-33.35 26.971-60.322 60.322-60.322z' style='opacity:${iconOpacity};fill:${alertColor};fill-opacity:${iconOpacity}' transform='translate(-104.582 -104.582)'/%3E%3Cpath d='M256 166.164c-49.591 0-89.836 40.245-89.836 89.836S206.41 345.836 256 345.836 345.836 305.59 345.836 256 305.59 166.164 256 166.164zm0 4c47.43 0 85.836 38.406 85.836 85.836S303.43 341.836 256 341.836 170.164 303.43 170.164 256 208.57 170.164 256 170.164z' style='opacity:${iconOpacity};fill:${alertColor};fill-opacity:${iconOpacity}' transform='translate(-104.582 -104.582)'/%3E%3Cpath d='M256 109.582c-80.853 0-146.418 65.565-146.418 146.418 0 80.853 65.565 146.418 146.418 146.418 80.853 0 146.418-65.565 146.418-146.418 0-80.853-65.565-146.418-146.418-146.418zm0 2c79.772 0 144.418 64.646 144.418 144.418S335.772 400.418 256 400.418 111.582 335.772 111.582 256 176.228 111.582 256 111.582z' style='opacity:${iconOpacity};fill:${alertColor};fill-opacity:.35' transform='translate(-104.582 -104.582)'/%3E%3C/svg%3E`;

					return L.icon({
						iconUrl: iconUrl,
						iconSize: [40, 40],
						iconAnchor: [20, 20],
						popupAnchor: [0, -20]
					});
				}

				// Create Leaflet GeoJSON layer for earthquakes
				overlayLayer = L.geoJSON(earthquakeData, {
					pointToLayer: function(feature, latlng) {
						return L.marker(latlng, { icon: getEarthquakeIcon(feature) });
					},
					onEachFeature: async function(feature, layer) {
						const props = feature.properties;
						let quakeTime = new Date(props.time);
						let alertLabel = "(not available)";
						let alertLabelColor = "white";
						if (props.alert != null) {
							alertLabelColor = props.alert;
							alertLabel = props.alert.toUpperCase();
							if (alertLabelColor == "green") {
								alertLabelColor = "lawngreen";
							}
						}
						let quakeAgeInDays = (new Date() - quakeTime) / (86400 * 1000);

					// Fetch detail data first to get impact-link info for tsunami warning...
					const detailUrl = props.detail;
					let tsunamiWarningHtml = 'Tsunami risk';
					let detailData = null;
					if (detailUrl) {
						try {
							const detailResponse = await fetch(detailUrl);
							detailData = await detailResponse.json();
							// Look for impact-link products...
							const impactLinks = detailData?.properties?.products?.["impact-link"];
							if (impactLinks && impactLinks.length > 0) {
								// Find the latest entry based on indexTime...
								const latestImpactLink = impactLinks.reduce((latest, current) => {
									const currentTime = current.properties?.indexTime || current.indexTime || 0;
									const latestTime = latest.properties?.indexTime || latest.indexTime || 0;
									return (currentTime > latestTime) ? current : latest;
								}, impactLinks[0]);
								// Get text and url from the latest impact-link...
								const impactText = latestImpactLink.properties?.text || latestImpactLink.text;
								const impactUrl = latestImpactLink.properties?.url || latestImpactLink.url;
								if (impactText && impactUrl) {
									// tsunamiWarningHtml = `<a href="${impactUrl}" target="_blank" style="color: #333; text-decoration: underline;">${impactText}</a>`;
									tsunamiWarningHtml = `<a href="${impactUrl}" title="View Tsunami details" target="_blank" style="color: #333; text-decoration: underline;">Tsunami Risk</a>`;
								}
							}
						} catch (err) {
							console.debug("Could not load detail data for impact-link:", err.message);
						}
					}

					// Build popup content for earthquake
					let updated = new Date(props.updated);
					const popupContent = `
						<div style="line-height:1.35;overflow:hidden;color:black;width:260px;">
							<div style="font-size: 1.2em;">
								<div style="font-weight:700;">Earthquake: Magnitude ${props.mag}</div>
								${props.place}
							</div>
							<div style="margin: 12px 0; display: flex; flex-direction: column; gap: 12px; min-width: 220px;">
								<div style="display: flex; flex-direction: column; gap: 4px;">
									<div style="display: flex; justify-content: space-between; align-items: baseline;">
										<span style="font-size: 11px; font-weight: 600; color: #333;">Magnitude</span>
										<span style="font-size: 14px; font-weight: 700; color: #333;">${props.mag.toFixed(1)}</span>
									</div>
								</div>
								<div style="display: flex; flex-direction: column; gap: 4px;">
									<div style="display: flex; justify-content: space-between; align-items: baseline;">
										<span style="font-size: 11px; font-weight: 600; color: #333;">Significance</span>
										<span style="font-size: 14px; font-weight: 700; color: #333;">${(props.sig || 0).toFixed(0)}</span>
									</div>
								</div>
								<div style="display: flex; flex-direction: column; gap: 4px;">
									<div style="display: flex; justify-content: space-between; align-items: baseline;">
										<span style="font-size: 11px; font-weight: 600; color: #333;">Intensity (MMI)</span>
										<span style="font-size: 14px; font-weight: 700; color: #333;">${(props.cdi || 0).toFixed(1)}</span>
									</div>
								</div>
							</div>
							${props.tsunami === 1 && quakeAgeInDays < 1 ? `
								<div style="display: flex; flex-wrap: wrap; text-wrap: auto; align-items: center; gap: 8px; justify-content: center;">
									<span style="font-weight: bold; color: #333;">${tsunamiWarningHtml}</span>
								</div>
							` : ''}
							<div style="margin: 15px 0;">PAGER Alert: <strong style="color: ${alertLabelColor}; background-color: black; padding: 5px; border-radius: 7px; font-size: 0.9em;">${alertLabel}</strong></div>
							<div style="font-size: 0.95em;">
								<span style="font-weight: 500;">Detected:</span> ${quakeTime.toLocaleString()} <span style="font-size: 0.95em;">(${quakeAgeInDays.toFixed(1)} days ago)</span><br/>
								<span style="font-weight: 500;">Updated:</span> ${updated.toLocaleString()}
							</div>
							<div style="margin: 15px 0 5px 0;">
								<a href="${props.url}" target="_blank" style="background-color: dodgerblue; padding: 3px 7px; border-radius: 5px; color: white; text-decoration: none; font-size: 1.15em; font-weight: 400; display: inline-flex; align-items: center; gap: 5px;">
									Earthquake details
								</a>
							</div>
						</div>`;

					// Bind popup to the layer
					layer.bindPopup(popupContent, { maxWidth: 320 });

					// Display ShakeMap MMI contour lines using the already-fetched detail data...
					// Clear any previous contour lines...
					if (parent.mmiContourLines) {
						parent.mmiContourLines.forEach(line => {
							if (map.hasLayer(line)) map.removeLayer(line);
						});
						parent.mmiContourLines = [];
					}
					parent.mmiContourLines = [];

					// Use the already-fetched detailData for ShakeMap product...
					if (detailData) {
						try {
							// Look for ShakeMap product with cont_mmi.json...
							const shakemapProduct = detailData?.properties?.products?.shakemap?.[0];
							const contMmiUrl = shakemapProduct?.contents?.["download/cont_mmi.json"]?.url;
							
							if (contMmiUrl) {
								const contMmiResponse = await fetch(contMmiUrl);
								const contMmiData = await contMmiResponse.json();
								
								// Find max and min MMI values for color scaling...
								let maxMmi = 0;
								let minMmi = Infinity;
								contMmiData.features.forEach(feature => {
									const mmi = feature.properties.value || 0;
									if (mmi > maxMmi) maxMmi = mmi;
									if (mmi < minMmi) minMmi = mmi;
								});
								
								// Add each contour line to the map with color based on MMI value...
								contMmiData.features.forEach(feature => {
									if (feature.geometry && feature.geometry.type === "MultiLineString") {
										const mmi = feature.properties.value || 0;
										// Calculate red intensity: higher MMI = stronger red (scale from light to dark red)
										// MMI typically ranges from ~1 to 10
										const intensity = Math.min(1, Math.max(0, (mmi - minMmi) / (maxMmi - minMmi)));
										// Create gradient from light red (#ffcccc) to dark red (#8b0000)
										const red = 255;
										const green = Math.round(204 * (1 - intensity));
										const blue = Math.round(204 * (1 - intensity));
										const strokeColor = "rgb(" + red + ", " + green + ", " + blue + ")";
										// Higher MMI = thicker, more opaque lines
										const strokeWeight = 1 + intensity;
										const strokeOpacity = 0.2 + (intensity * 0.5);
										
										// MultiLineString has multiple line arrays
										feature.geometry.coordinates.forEach(lineCoords => {
											const path = lineCoords.map(coord => [coord[1], coord[0]]);
											const polyline = L.polyline(path, {
												color: strokeColor,
												opacity: strokeOpacity,
												weight: strokeWeight
											}).addTo(map);
											parent.mmiContourLines.push(polyline);
										});
									}
								});
								console.debug("Loaded " + parent.mmiContourLines.length + " MMI contour lines");
							}
						} catch (err) {
							console.debug("Could not load ShakeMap MMI data:", err.message);
						}
					}
					}
				}).addTo(map);
			} else if (optionalMapType == "us-flooding") {
				// const countiesGeoJsonURL = `https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json?v=${Date.now()}`;
				// const countyIDsJsonURL = `https://api.waterdata.usgs.gov/rtfi-api/counties?page=1&limit=4000&v=${Date.now()}`;
				const floodingDataURL = `https://api.waterdata.usgs.gov/rtfi-api/referencepoints/flooding?v=${Date.now()}`;

				// Clear any previous overlay layer...
				if (overlayLayer && map.hasLayer(overlayLayer)) {
					map.removeLayer(overlayLayer);
					overlayLayer = null;
				}
				// Clear any previous earthquake contour lines...
				if (parent.mmiContourLines) {
					parent.mmiContourLines.forEach(line => {
						if (map.hasLayer(line)) map.removeLayer(line);
					});
					parent.mmiContourLines = [];
				}

				try {
					// Fetch the flooding data from the USGS API...
					// See https://api.waterdata.usgs.gov/rtfi-api/docs for more information on the API.
					const floodingResponse = await fetch(floodingDataURL);
					if (!floodingResponse.ok) {
						throw new Error(`Flooding data fetch error: ${floodingResponse.status}`);
					}
					const floodingData = await floodingResponse.json();
					console.debug(`Flooding data loaded: ${floodingData.length} sites currently flooding`);

					// Convert flooding data to GeoJSON feature collection...
					const floodingGeoJson = {
						type: "FeatureCollection",
						features: floodingData.filter(entry => entry.latitude && entry.longitude).map(entry => ({
							type: "Feature",
							geometry: {
								type: "Point",
								coordinates: [parseFloat(entry.longitude), parseFloat(entry.latitude)]
							},
							properties: entry
						}))
					};

					// Create Leaflet GeoJSON layer with circle markers...
					if (overlayLayer && map.hasLayer(overlayLayer)) {
						map.removeLayer(overlayLayer);
					}
					overlayLayer = L.geoJSON(floodingGeoJson, {
						pointToLayer: function(feature, latlng) {
							return L.circleMarker(latlng, {
								radius: 8,
								fillColor: '#87ceeb',
								fillOpacity: 0.9,
								color: '#4682b4',
								weight: 1
							});
						},
						onEachFeature: function(feature, layer) {
							const data = feature.properties;
							const popupContent = `
								<div style="line-height:1.5;overflow:hidden;color:#333;max-width:300px;">
									<h3 style="margin:0 0 8px 0;color:#4682B4;">${data.site_name || 'Unknown Site'}</h3>
									<p style="margin:0;font-size:13px;">${data.description || 'No description available'}</p>
									<div style="margin-top:12px;">
										<div style="position:relative;width:100%;height:auto;">
											${data.gage_height && data.rp_elevation ? `
											<div style="position:relative;width:80%;margin:0 auto;">
												<svg style="position:absolute;top:-8px;left:0;width:100%;height:10px;" viewBox="0 0 100 10" preserveAspectRatio="none">
													<path d="M0,10 L0,5 Q12.5,0 25,5 T50,5 T75,5 T100,5 L100,10 Z" fill="#ffb3b3"/>
												</svg>
												<div style="
													background: linear-gradient(to bottom, #ffb3b3, #fe8787);
													height:${Math.max(20, Math.min(60, (parseFloat(data.gage_height) - parseFloat(data.rp_elevation)) * 5))}px;
													width:100%;
													border-radius:4px 4px 0 0;
													display:flex;
													align-items:center;
													justify-content:center;
													color:#8b0000;
													font-weight:bold;
													font-size:12px;
												">
													<span style="margin-top: -5px; filter: drop-shadow(0 0 4px white);">+${(parseFloat(data.gage_height) - parseFloat(data.rp_elevation)).toFixed(2)} ft</span>
												</div>
												<div style="position:relative;">
													<svg style="position:absolute;top:-8px;left:0;width:100%;height:10px;" viewBox="0 0 100 10" preserveAspectRatio="none">
														<path d="M0,10 L0,5 Q12.5,0 25,5 T50,5 T75,5 T100,5 L100,10 Z" fill="#87CEEB"/>
													</svg>
													<div style="
														background: linear-gradient(to bottom, #87CEEB, #8ea6ba);
														height:40px;
														width:100%;
														border-radius:0 0 4px 4px;
														display:flex;
														align-items:center;
														justify-content:center;
														color:#142d47;
														font-weight:bold;
														font-size:12px;
													">
														<span style="filter: drop-shadow(0 0 4px white);">Normal Elevation: ${parseFloat(data.rp_elevation).toFixed(2)} ft</span>
													</div>
												</div>
											</div>
											` : ''}
										</div>
									</div>
									<div style="margin: 30px 0 5px 0;">
										<a href="https://waterdata.usgs.gov/monitoring-location/USGS-${data.nwis_id}/all-graphs/#period=P7D" target="_blank" style="background-color: dodgerblue; padding: 3px 7px; border-radius: 5px; color: white; text-decoration: none; font-size: 1.05em; font-weight: 400; display: inline-flex; align-items: center; gap: 5px;" title="View USGS monitoring station details">
											<svg xmlns="http://www.w3.org/2000/svg" class="infoDialogIcon" viewBox="0 0 640 640"><path fill="white" d="M384 64C366.3 64 352 78.3 352 96C352 113.7 366.3 128 384 128L466.7 128L265.3 329.4C252.8 341.9 252.8 362.2 265.3 374.7C277.8 387.2 298.1 387.2 310.6 374.7L512 173.3L512 256C512 273.7 526.3 288 544 288C561.7 288 576 273.7 576 256L576 96C576 78.3 561.7 64 544 64L384 64zM144 160C99.8 160 64 195.8 64 240L64 496C64 540.2 99.8 576 144 576L400 576C444.2 576 480 540.2 480 496L480 416C480 398.3 465.7 384 448 384C430.3 384 416 398.3 416 416L416 496C416 504.8 408.8 512 400 512L144 512C135.2 512 128 504.8 128 496L128 240C128 231.2 135.2 224 144 224L224 224C241.7 224 256 209.7 256 192C256 174.3 241.7 160 224 160L144 160z"/></svg>
											USGS monitoring station details
										</a>
									</div>
								</div>
							`;
							layer.bindPopup(popupContent, { maxWidth: 350 });
						}
					}).addTo(map);
					console.debug(`Flooding layer added with ${floodingGeoJson.features.length} features`);
				} catch (error) {
					console.error("Failed to fetch flooding data:", error);
				}
			// Add hurricane/tropical storm layer using NOAA NHC WMS...
			} else if (optionalMapType == "hurricanes") {
				// Remove any previous overlay layer...
				if (overlayLayer && map.hasLayer(overlayLayer)) {
					map.removeLayer(overlayLayer);
					overlayLayer = null;
				}
				if (hurricaneLayer && map.hasLayer(hurricaneLayer)) {
					map.removeLayer(hurricaneLayer);
				}

				// Create NOAA NHC WMS layer for tropical cyclones
				// This shows current tropical storm tracks, cones of uncertainty, and watches/warnings
				hurricaneLayer = L.tileLayer.wms('https://nowcoast.noaa.gov/geoserver/wms', {
					layers: 'obs_meteocean_insitu_sfc_time',
					format: 'image/png',
					transparent: true,
					opacity: 0.7,
					attribution: 'Hurricane data &copy; <a href="https://www.nhc.noaa.gov/">NOAA NHC</a>'
				}).addTo(map);

				// Also add the hurricane forecast track layer
				const hurricaneTrackLayer = L.tileLayer.wms('https://nowcoast.noaa.gov/geoserver/wms', {
					layers: 'forecasts_tropical_cyclone',
					format: 'image/png',
					transparent: true,
					opacity: 0.8
				}).addTo(map);

				console.debug("Hurricane layers loaded from NOAA NHC");

			// Add Air Quality Index layer using EPA AirNow data...
			} else if (optionalMapType == "air-quality") {
				// Remove any previous overlay layer...
				if (overlayLayer && map.hasLayer(overlayLayer)) {
					map.removeLayer(overlayLayer);
					overlayLayer = null;
				}
				if (aqiLayer && map.hasLayer(aqiLayer)) {
					map.removeLayer(aqiLayer);
				}

				// EPA AirNow AQI contours from ArcGIS
				const aqiUrl = `https://services.arcgis.com/cJ9YHowT8TU7DUyn/arcgis/rest/services/AirNowLatestContoursCombined/FeatureServer/0/query?where=1%3D1&outFields=*&f=geojson&ts=${Date.now()}`;

				fetch(aqiUrl)
					.then(response => response.ok ? response.json() : null)
					.then(data => {
						if (data && data.features) {
							// AQI color scale
							const getAQIColor = (aqi) => {
								if (aqi <= 50) return '#00e400'; // Good - Green
								if (aqi <= 100) return '#ffff00'; // Moderate - Yellow
								if (aqi <= 150) return '#ff7e00'; // Unhealthy for Sensitive - Orange
								if (aqi <= 200) return '#ff0000'; // Unhealthy - Red
								if (aqi <= 300) return '#8f3f97'; // Very Unhealthy - Purple
								return '#7e0023'; // Hazardous - Maroon
							};

							const getAQICategory = (aqi) => {
								if (aqi <= 50) return 'Good';
								if (aqi <= 100) return 'Moderate';
								if (aqi <= 150) return 'Unhealthy for Sensitive Groups';
								if (aqi <= 200) return 'Unhealthy';
								if (aqi <= 300) return 'Very Unhealthy';
								return 'Hazardous';
							};

							aqiLayer = L.geoJSON(data, {
								style: function(feature) {
									const aqi = feature.properties.gridcode || feature.properties.AQI || 0;
									return {
										fillColor: getAQIColor(aqi),
										fillOpacity: 0.4,
										weight: 1,
										color: getAQIColor(aqi),
										opacity: 0.8
									};
								},
								onEachFeature: function(feature, layer) {
									const aqi = feature.properties.gridcode || feature.properties.AQI || 'N/A';
									const category = getAQICategory(parseInt(aqi) || 0);
									const pollutant = feature.properties.Pollutant || 'Combined';
									
									const popupContent = `
										<div style="line-height:1.35;color:black;">
											<span style="font-weight:700;">Air Quality Index</span><br/>
											<br/><b>AQI:</b> ${aqi}
											<br/><b>Category:</b> ${category}
											<br/><b>Pollutant:</b> ${pollutant}
										</div>
									`;
									layer.bindPopup(popupContent);
								}
							}).addTo(map);

							console.debug(`AQI data loaded: ${data.features.length} contours`);
						}
					})
					.catch(error => {
						console.error("Failed to fetch AQI data:", error);
					});
			}
		}
	}

	// Function called when the "Reset Zoom" button is pressed...
	function resetZoom() {
		// If there's only 1 marker, avoid zooming in super close (i.e. use the default zoom level 3)...
		if (markers.length > 0 && bounds && bounds.isValid()) {
			// Add padding to avoid markers appearing under the map's UI controls...
			map.fitBounds(bounds, {
				padding: [70, 70]
			});
		}
	}

	// Function to capture presses of the Enter key in the 'Group Filter' field (without this the widget refreshes in an error)...
	function groupkeyHandler(e) {
		// Get the keycode of which key was pressed...
		let key = e.keyCode || e.which;
		// If the key was the Enter/Return key...
		if (key == 13) {
			// Stop the form from submitting...
			e.preventDefault();
			// Refresh the group data...
			refreshGroupData();
		}
	}

	function toggleMiscOptions() {
		let areaElement = document.getElementById("optionsToggleArea");
		let gearIcon = document.getElementById("gearIcon");
		let gearIconChevron = document.getElementById("gearIconChevron");

		if (areaElement.style.display == "flex") {
			areaElement.style.display = "none";
			gearIcon.style.fill = "#aaa";
			gearIconChevron.style.display = "none";
		} else {
			areaElement.style.display = "flex";
			gearIcon.style.fill = "blue";
			// gearIcon.style.fill = "#555";
			gearIconChevron.style.display = "block";
		}
	}

	function waitForElm(selector) {
		return new Promise(resolve => {
			if (document.querySelector(selector)) {
				return resolve(document.querySelector(selector));
			}

			const observer = new MutationObserver(mutations => {
				if (document.querySelector(selector)) {
					observer.disconnect();
					resolve(document.querySelector(selector));
				}
			});

			// If you get "parameter 1 is not of type 'Node'" error, see https://stackoverflow.com/a/77855838/492336
			observer.observe(document.body, {
				childList: true,
				subtree: true
			});
		});
	}
</script>

<!-- Leaflet MarkerCluster is loaded via CDN in the head section -->